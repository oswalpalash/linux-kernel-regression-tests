// https://syzkaller.appspot.com/bug?id=d78a470edb0c565922f977d1ea39dbceb08bb1de
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <setjmp.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

static __thread int clone_ongoing;
static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  if (__atomic_load_n(&clone_ongoing, __ATOMIC_RELAXED) != 0) {
    exit(sig);
  }
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  int skip = __atomic_load_n(&skip_segv, __ATOMIC_RELAXED) != 0;
  int valid = addr < prog_start || addr > prog_end;
  if (skip && valid) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  ({                                                                           \
    int ok = 1;                                                                \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    } else                                                                     \
      ok = 0;                                                                  \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    ok;                                                                        \
  })

uint64_t r[1] = {0xffffffffffffffff};

int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x3ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul, /*fd=*/-1,
          /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x400000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul, /*fd=*/-1,
          /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x400001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul, /*fd=*/-1,
          /*offset=*/0ul);
  const char* reason;
  (void)reason;
  install_segv_handler();
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  res = syscall(__NR_socket, /*domain=*/0xaul, /*type=*/1ul, /*proto=*/0);
  if (res != -1)
    r[0] = res;
  NONFAILING(*(uint32_t*)0x400000000000 = 1);
  syscall(__NR_setsockopt, /*fd=*/r[0], /*level=*/6,
          /*optname=TCP_THIN_LINEAR_TIMEOUTS|TCP_CORK*/ 0x13,
          /*optval=*/0x400000000000ul, /*optlen=*/4ul);
  NONFAILING(*(uint16_t*)0x400000000200 = 0xa);
  NONFAILING(*(uint16_t*)0x400000000202 = htobe16(0));
  NONFAILING(*(uint32_t*)0x400000000204 = htobe32(0));
  NONFAILING(*(uint64_t*)0x400000000208 = htobe64(0));
  NONFAILING(*(uint64_t*)0x400000000210 = htobe64(1));
  NONFAILING(*(uint32_t*)0x400000000218 = 0);
  syscall(__NR_connect, /*fd=*/r[0], /*addr=*/0x400000000200ul,
          /*addrlen=*/0x1cul);
  NONFAILING(memcpy((void*)0x4000000000c0, "tls\000", 4));
  syscall(__NR_setsockopt, /*fd=*/r[0], /*level=*/6, /*optname=*/0x1f,
          /*optval=*/0x4000000000c0ul, /*optlen=*/4ul);
  NONFAILING(*(uint32_t*)0x400000000080 = 1);
  syscall(__NR_setsockopt, /*fd=*/r[0], /*level=*/6, /*optname=*/0x14,
          /*optval=*/0x400000000080ul, /*optlen=*/4ul);
  NONFAILING(*(uint16_t*)0x400000000140 = 0x303);
  NONFAILING(*(uint16_t*)0x400000000142 = 0x33);
  NONFAILING(
      memcpy((void*)0x400000000144, "\xb3\x91\x62\xa1\xdc\x8b\x4c\x3f", 8));
  NONFAILING(memcpy(
      (void*)0x40000000014c,
      "\x7e\xa8\xf8\x6a\xc3\x96\x96\xdc\xed\xdf\x8c\x42\x1b\xbd\xcc\x0f", 16));
  NONFAILING(memset((void*)0x40000000015c, 0, 4));
  NONFAILING(
      memcpy((void*)0x400000000160, "\xf9\x80\x9f\xe3\x9a\x1d\xaf\xc9", 8));
  syscall(__NR_setsockopt, /*fd=*/r[0], /*level=*/0x11a, /*optname=*/1,
          /*optval=*/0x400000000140ul, /*optlen=*/0x28ul);
  NONFAILING(*(uint64_t*)0x400000000180 = 0);
  NONFAILING(*(uint32_t*)0x400000000188 = 0);
  NONFAILING(*(uint64_t*)0x400000000190 = 0x4000000008c0);
  NONFAILING(*(uint64_t*)0x4000000008c0 = 0x400000000240);
  NONFAILING(memcpy((void*)0x400000000240, "n7", 2));
  NONFAILING(*(uint64_t*)0x4000000008c8 = 2);
  NONFAILING(*(uint64_t*)0x400000000198 = 1);
  NONFAILING(*(uint64_t*)0x4000000001a0 = 0);
  NONFAILING(*(uint64_t*)0x4000000001a8 = 0);
  NONFAILING(*(uint32_t*)0x4000000001b0 = 0);
  syscall(__NR_sendmsg, /*fd=*/r[0], /*msg=*/0x400000000180ul, /*f=*/0ul);
  NONFAILING(*(uint16_t*)0x400000000680 = 0x303);
  NONFAILING(*(uint16_t*)0x400000000682 = 0x33);
  NONFAILING(
      memcpy((void*)0x400000000684, "\x00\x00\x37\xd7\x00\x94\x00\x00", 8));
  NONFAILING(memcpy(
      (void*)0x40000000068c,
      "\xc0\xb6\xc5\xb2\x9c\xa2\xb8\x38\xd4\x1a\xc2\xfc\x7d\xdf\x97\x2d", 16));
  NONFAILING(memcpy((void*)0x40000000069c, "\xe9\xbe\x1e\xae", 4));
  NONFAILING(
      memcpy((void*)0x4000000006a0, "\xbb\x10\x00\x00\x00\x00\x00\x01", 8));
  syscall(__NR_setsockopt, /*fd=*/r[0], /*level=*/0x11a, /*optname=*/2,
          /*optval=*/0x400000000680ul, /*optlen=*/0x28ul);
  syscall(
      __NR_mmap, /*addr=*/0x400000000000ul, /*len=*/0x95c000ul,
      /*prot=PROT_GROWSDOWN|PROT_READ*/ 0x1000001ul,
      /*flags=MAP_UNINITIALIZED|MAP_POPULATE|MAP_NORESERVE|MAP_NONBLOCK|MAP_HUGETLB|0x8c4b815a506002b1*/
      0x8c4b815a5465c2b1ul, /*fd=*/-1, /*offset=*/0ul);
  NONFAILING(*(uint16_t*)0x400000000200 = 0xa);
  NONFAILING(*(uint16_t*)0x400000000202 = htobe16(0));
  NONFAILING(*(uint32_t*)0x400000000204 = htobe32(0));
  NONFAILING(*(uint64_t*)0x400000000208 = htobe64(0));
  NONFAILING(*(uint64_t*)0x400000000210 = htobe64(1));
  NONFAILING(*(uint32_t*)0x400000000218 = 0);
  syscall(__NR_connect, /*fd=*/r[0], /*addr=*/0x400000000200ul,
          /*addrlen=*/0x1cul);
  syscall(__NR_recvfrom, /*fd=*/r[0], /*buf=*/0x400000000100ul,
          /*len=*/0x1ff4ul, /*f=MSG_DONTWAIT*/ 0x40ul, /*addr=*/0ul,
          /*addrlen=*/0ul);
  return 0;
}
