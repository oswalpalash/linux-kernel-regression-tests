// https://syzkaller.appspot.com/bug?id=beab55c4cae03ef184d4417017fbb439403a3597
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/usb/ch9.h>

static unsigned long long procid;

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

#define MAX_FDS 30

#define USB_MAX_IFACE_NUM 4
#define USB_MAX_EP_NUM 32
#define USB_MAX_FDS 6

struct usb_endpoint_index {
  struct usb_endpoint_descriptor desc;
  int handle;
};

struct usb_iface_index {
  struct usb_interface_descriptor* iface;
  uint8_t bInterfaceNumber;
  uint8_t bAlternateSetting;
  uint8_t bInterfaceClass;
  struct usb_endpoint_index eps[USB_MAX_EP_NUM];
  int eps_num;
};

struct usb_device_index {
  struct usb_device_descriptor* dev;
  struct usb_config_descriptor* config;
  uint8_t bDeviceClass;
  uint8_t bMaxPower;
  int config_length;
  struct usb_iface_index ifaces[USB_MAX_IFACE_NUM];
  int ifaces_num;
  int iface_cur;
};

struct usb_info {
  int fd;
  struct usb_device_index index;
};

static struct usb_info usb_devices[USB_MAX_FDS];
static int usb_devices_num;

static bool parse_usb_descriptor(const char* buffer, size_t length,
                                 struct usb_device_index* index)
{
  if (length < sizeof(*index->dev) + sizeof(*index->config))
    return false;
  memset(index, 0, sizeof(*index));
  index->dev = (struct usb_device_descriptor*)buffer;
  index->config = (struct usb_config_descriptor*)(buffer + sizeof(*index->dev));
  index->bDeviceClass = index->dev->bDeviceClass;
  index->bMaxPower = index->config->bMaxPower;
  index->config_length = length - sizeof(*index->dev);
  index->iface_cur = -1;
  size_t offset = 0;
  while (true) {
    if (offset + 1 >= length)
      break;
    uint8_t desc_length = buffer[offset];
    uint8_t desc_type = buffer[offset + 1];
    if (desc_length <= 2)
      break;
    if (offset + desc_length > length)
      break;
    if (desc_type == USB_DT_INTERFACE &&
        index->ifaces_num < USB_MAX_IFACE_NUM) {
      struct usb_interface_descriptor* iface =
          (struct usb_interface_descriptor*)(buffer + offset);
      index->ifaces[index->ifaces_num].iface = iface;
      index->ifaces[index->ifaces_num].bInterfaceNumber =
          iface->bInterfaceNumber;
      index->ifaces[index->ifaces_num].bAlternateSetting =
          iface->bAlternateSetting;
      index->ifaces[index->ifaces_num].bInterfaceClass = iface->bInterfaceClass;
      index->ifaces_num++;
    }
    if (desc_type == USB_DT_ENDPOINT && index->ifaces_num > 0) {
      struct usb_iface_index* iface = &index->ifaces[index->ifaces_num - 1];
      if (iface->eps_num < USB_MAX_EP_NUM) {
        memcpy(&iface->eps[iface->eps_num].desc, buffer + offset,
               sizeof(iface->eps[iface->eps_num].desc));
        iface->eps_num++;
      }
    }
    offset += desc_length;
  }
  return true;
}

static struct usb_device_index* add_usb_index(int fd, const char* dev,
                                              size_t dev_len)
{
  int i = __atomic_fetch_add(&usb_devices_num, 1, __ATOMIC_RELAXED);
  if (i >= USB_MAX_FDS)
    return NULL;
  if (!parse_usb_descriptor(dev, dev_len, &usb_devices[i].index))
    return NULL;
  __atomic_store_n(&usb_devices[i].fd, fd, __ATOMIC_RELEASE);
  return &usb_devices[i].index;
}

static struct usb_device_index* lookup_usb_index(int fd)
{
  for (int i = 0; i < USB_MAX_FDS; i++) {
    if (__atomic_load_n(&usb_devices[i].fd, __ATOMIC_ACQUIRE) == fd) {
      return &usb_devices[i].index;
    }
  }
  return NULL;
}

struct vusb_connect_string_descriptor {
  uint32_t len;
  char* str;
} __attribute__((packed));

struct vusb_connect_descriptors {
  uint32_t qual_len;
  char* qual;
  uint32_t bos_len;
  char* bos;
  uint32_t strs_len;
  struct vusb_connect_string_descriptor strs[0];
} __attribute__((packed));

static const char default_string[] = {8, USB_DT_STRING, 's', 0, 'y', 0, 'z', 0};

static const char default_lang_id[] = {4, USB_DT_STRING, 0x09, 0x04};

static bool
lookup_connect_response_in(int fd, const struct vusb_connect_descriptors* descs,
                           const struct usb_ctrlrequest* ctrl,
                           char** response_data, uint32_t* response_length)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  uint8_t str_idx;
  if (!index)
    return false;
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_GET_DESCRIPTOR:
      switch (ctrl->wValue >> 8) {
      case USB_DT_DEVICE:
        *response_data = (char*)index->dev;
        *response_length = sizeof(*index->dev);
        return true;
      case USB_DT_CONFIG:
        *response_data = (char*)index->config;
        *response_length = index->config_length;
        return true;
      case USB_DT_STRING:
        str_idx = (uint8_t)ctrl->wValue;
        if (descs && str_idx < descs->strs_len) {
          *response_data = descs->strs[str_idx].str;
          *response_length = descs->strs[str_idx].len;
          return true;
        }
        if (str_idx == 0) {
          *response_data = (char*)&default_lang_id[0];
          *response_length = default_lang_id[0];
          return true;
        }
        *response_data = (char*)&default_string[0];
        *response_length = default_string[0];
        return true;
      case USB_DT_BOS:
        *response_data = descs->bos;
        *response_length = descs->bos_len;
        return true;
      case USB_DT_DEVICE_QUALIFIER:
        if (!descs->qual) {
          struct usb_qualifier_descriptor* qual =
              (struct usb_qualifier_descriptor*)response_data;
          qual->bLength = sizeof(*qual);
          qual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;
          qual->bcdUSB = index->dev->bcdUSB;
          qual->bDeviceClass = index->dev->bDeviceClass;
          qual->bDeviceSubClass = index->dev->bDeviceSubClass;
          qual->bDeviceProtocol = index->dev->bDeviceProtocol;
          qual->bMaxPacketSize0 = index->dev->bMaxPacketSize0;
          qual->bNumConfigurations = index->dev->bNumConfigurations;
          qual->bRESERVED = 0;
          *response_length = sizeof(*qual);
          return true;
        }
        *response_data = descs->qual;
        *response_length = descs->qual_len;
        return true;
      default:
        break;
      }
      break;
    default:
      break;
    }
    break;
  default:
    break;
  }
  return false;
}

typedef bool (*lookup_connect_out_response_t)(
    int fd, const struct vusb_connect_descriptors* descs,
    const struct usb_ctrlrequest* ctrl, bool* done);

#define ATH9K_FIRMWARE_DOWNLOAD 0x30
#define ATH9K_FIRMWARE_DOWNLOAD_COMP 0x31

static bool lookup_connect_response_out_ath9k(
    int fd, const struct vusb_connect_descriptors* descs,
    const struct usb_ctrlrequest* ctrl, bool* done)
{
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_SET_CONFIGURATION:
      return true;
    default:
      break;
    }
    break;
  case USB_TYPE_VENDOR:
    switch (ctrl->bRequest) {
    case ATH9K_FIRMWARE_DOWNLOAD:
      return true;
    case ATH9K_FIRMWARE_DOWNLOAD_COMP:
      *done = true;
      return true;
    default:
      break;
    }
    break;
  }
  return false;
}

#define UDC_NAME_LENGTH_MAX 128

struct usb_raw_init {
  __u8 driver_name[UDC_NAME_LENGTH_MAX];
  __u8 device_name[UDC_NAME_LENGTH_MAX];
  __u8 speed;
};

enum usb_raw_event_type {
  USB_RAW_EVENT_INVALID = 0,
  USB_RAW_EVENT_CONNECT = 1,
  USB_RAW_EVENT_CONTROL = 2,
};

struct usb_raw_event {
  __u32 type;
  __u32 length;
  __u8 data[0];
};

struct usb_raw_ep_io {
  __u16 ep;
  __u16 flags;
  __u32 length;
  __u8 data[0];
};

#define USB_RAW_EPS_NUM_MAX 30
#define USB_RAW_EP_NAME_MAX 16
#define USB_RAW_EP_ADDR_ANY 0xff

struct usb_raw_ep_caps {
  __u32 type_control : 1;
  __u32 type_iso : 1;
  __u32 type_bulk : 1;
  __u32 type_int : 1;
  __u32 dir_in : 1;
  __u32 dir_out : 1;
};

struct usb_raw_ep_limits {
  __u16 maxpacket_limit;
  __u16 max_streams;
  __u32 reserved;
};

struct usb_raw_ep_info {
  __u8 name[USB_RAW_EP_NAME_MAX];
  __u32 addr;
  struct usb_raw_ep_caps caps;
  struct usb_raw_ep_limits limits;
};

struct usb_raw_eps_info {
  struct usb_raw_ep_info eps[USB_RAW_EPS_NUM_MAX];
};

#define USB_RAW_IOCTL_INIT _IOW('U', 0, struct usb_raw_init)
#define USB_RAW_IOCTL_RUN _IO('U', 1)
#define USB_RAW_IOCTL_EVENT_FETCH _IOR('U', 2, struct usb_raw_event)
#define USB_RAW_IOCTL_EP0_WRITE _IOW('U', 3, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP0_READ _IOWR('U', 4, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_ENABLE _IOW('U', 5, struct usb_endpoint_descriptor)
#define USB_RAW_IOCTL_EP_DISABLE _IOW('U', 6, __u32)
#define USB_RAW_IOCTL_EP_WRITE _IOW('U', 7, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_READ _IOWR('U', 8, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_CONFIGURE _IO('U', 9)
#define USB_RAW_IOCTL_VBUS_DRAW _IOW('U', 10, __u32)
#define USB_RAW_IOCTL_EPS_INFO _IOR('U', 11, struct usb_raw_eps_info)
#define USB_RAW_IOCTL_EP0_STALL _IO('U', 12)
#define USB_RAW_IOCTL_EP_SET_HALT _IOW('U', 13, __u32)
#define USB_RAW_IOCTL_EP_CLEAR_HALT _IOW('U', 14, __u32)
#define USB_RAW_IOCTL_EP_SET_WEDGE _IOW('U', 15, __u32)

static int usb_raw_open()
{
  return open("/dev/raw-gadget", O_RDWR);
}

static int usb_raw_init(int fd, uint32_t speed, const char* driver,
                        const char* device)
{
  struct usb_raw_init arg;
  strncpy((char*)&arg.driver_name[0], driver, sizeof(arg.driver_name));
  strncpy((char*)&arg.device_name[0], device, sizeof(arg.device_name));
  arg.speed = speed;
  return ioctl(fd, USB_RAW_IOCTL_INIT, &arg);
}

static int usb_raw_run(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_RUN, 0);
}

static int usb_raw_event_fetch(int fd, struct usb_raw_event* event)
{
  return ioctl(fd, USB_RAW_IOCTL_EVENT_FETCH, event);
}

static int usb_raw_ep0_write(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_WRITE, io);
}

static int usb_raw_ep0_read(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_READ, io);
}

static int usb_raw_ep_write(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_WRITE, io);
}

static int usb_raw_ep_enable(int fd, struct usb_endpoint_descriptor* desc)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_ENABLE, desc);
}

static int usb_raw_ep_disable(int fd, int ep)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_DISABLE, ep);
}

static int usb_raw_configure(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_CONFIGURE, 0);
}

static int usb_raw_vbus_draw(int fd, uint32_t power)
{
  return ioctl(fd, USB_RAW_IOCTL_VBUS_DRAW, power);
}

static int usb_raw_ep0_stall(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_STALL, 0);
}

static int lookup_endpoint(int fd, uint8_t bEndpointAddress)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return -1;
  if (index->iface_cur < 0)
    return -1;
  for (int ep = 0; index->ifaces[index->iface_cur].eps_num; ep++)
    if (index->ifaces[index->iface_cur].eps[ep].desc.bEndpointAddress ==
        bEndpointAddress)
      return index->ifaces[index->iface_cur].eps[ep].handle;
  return -1;
}

static void set_interface(int fd, int n)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return;
  if (index->iface_cur >= 0 && index->iface_cur < index->ifaces_num) {
    for (int ep = 0; ep < index->ifaces[index->iface_cur].eps_num; ep++) {
      int rv = usb_raw_ep_disable(
          fd, index->ifaces[index->iface_cur].eps[ep].handle);
      if (rv < 0) {
      } else {
      }
    }
  }
  if (n >= 0 && n < index->ifaces_num) {
    for (int ep = 0; ep < index->ifaces[n].eps_num; ep++) {
      int rv = usb_raw_ep_enable(fd, &index->ifaces[n].eps[ep].desc);
      if (rv < 0) {
      } else {
        index->ifaces[n].eps[ep].handle = rv;
      }
    }
    index->iface_cur = n;
  }
}

static int configure_device(int fd)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return -1;
  int rv = usb_raw_vbus_draw(fd, index->bMaxPower);
  if (rv < 0) {
    return rv;
  }
  rv = usb_raw_configure(fd);
  if (rv < 0) {
    return rv;
  }
  set_interface(fd, 0);
  return 0;
}

#define USB_MAX_PACKET_SIZE 4096

struct usb_raw_control_event {
  struct usb_raw_event inner;
  struct usb_ctrlrequest ctrl;
  char data[USB_MAX_PACKET_SIZE];
};

struct usb_raw_ep_io_data {
  struct usb_raw_ep_io inner;
  char data[USB_MAX_PACKET_SIZE];
};

static volatile long
syz_usb_connect_impl(uint64_t speed, uint64_t dev_len, const char* dev,
                     const struct vusb_connect_descriptors* descs,
                     lookup_connect_out_response_t lookup_connect_response_out)
{
  if (!dev) {
    return -1;
  }
  int fd = usb_raw_open();
  if (fd < 0) {
    return fd;
  }
  if (fd >= MAX_FDS) {
    close(fd);
    return -1;
  }
  struct usb_device_index* index = add_usb_index(fd, dev, dev_len);
  if (!index) {
    return -1;
  }
  char device[32];
  sprintf(&device[0], "dummy_udc.%llu", procid);
  int rv = usb_raw_init(fd, speed, "dummy_udc", &device[0]);
  if (rv < 0) {
    return rv;
  }
  rv = usb_raw_run(fd);
  if (rv < 0) {
    return rv;
  }
  bool done = false;
  while (!done) {
    struct usb_raw_control_event event;
    event.inner.type = 0;
    event.inner.length = sizeof(event.ctrl);
    rv = usb_raw_event_fetch(fd, (struct usb_raw_event*)&event);
    if (rv < 0) {
      return rv;
    }
    if (event.inner.type != USB_RAW_EVENT_CONTROL)
      continue;
    char* response_data = NULL;
    uint32_t response_length = 0;
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      if (!lookup_connect_response_in(fd, descs, &event.ctrl, &response_data,
                                      &response_length)) {
        usb_raw_ep0_stall(fd);
        continue;
      }
    } else {
      if (!lookup_connect_response_out(fd, descs, &event.ctrl, &done)) {
        usb_raw_ep0_stall(fd);
        continue;
      }
      response_data = NULL;
      response_length = event.ctrl.wLength;
    }
    if ((event.ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD &&
        event.ctrl.bRequest == USB_REQ_SET_CONFIGURATION) {
      rv = configure_device(fd);
      if (rv < 0) {
        return rv;
      }
    }
    struct usb_raw_ep_io_data response;
    response.inner.ep = 0;
    response.inner.flags = 0;
    if (response_length > sizeof(response.data))
      response_length = 0;
    if (event.ctrl.wLength < response_length)
      response_length = event.ctrl.wLength;
    response.inner.length = response_length;
    if (response_data)
      memcpy(&response.data[0], response_data, response_length);
    else
      memset(&response.data[0], 0, response_length);
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      rv = usb_raw_ep0_write(fd, (struct usb_raw_ep_io*)&response);
    } else {
      rv = usb_raw_ep0_read(fd, (struct usb_raw_ep_io*)&response);
    }
    if (rv < 0) {
      return rv;
    }
  }
  sleep_ms(200);
  return fd;
}

static volatile long syz_usb_connect_ath9k(volatile long a0, volatile long a1,
                                           volatile long a2, volatile long a3)
{
  uint64_t speed = a0;
  uint64_t dev_len = a1;
  const char* dev = (const char*)a2;
  const struct vusb_connect_descriptors* descs =
      (const struct vusb_connect_descriptors*)a3;
  return syz_usb_connect_impl(speed, dev_len, dev, descs,
                              &lookup_connect_response_out_ath9k);
}

static volatile long syz_usb_ep_write(volatile long a0, volatile long a1,
                                      volatile long a2, volatile long a3)
{
  int fd = a0;
  uint8_t ep = a1;
  uint32_t len = a2;
  char* data = (char*)a3;
  int ep_handle = lookup_endpoint(fd, ep);
  if (ep_handle < 0) {
    return -1;
  }
  struct usb_raw_ep_io_data io_data;
  io_data.inner.ep = ep_handle;
  io_data.inner.flags = 0;
  if (len > sizeof(io_data.data))
    len = sizeof(io_data.data);
  io_data.inner.length = len;
  memcpy(&io_data.data[0], data, len);
  int rv = usb_raw_ep_write(fd, (struct usb_raw_ep_io*)&io_data);
  if (rv < 0) {
    return rv;
  }
  sleep_ms(200);
  return 0;
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  for (int i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter = 0;
  for (;; iter++) {
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5000) {
        continue;
      }
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[1] = {0xffffffffffffffff};

void execute_one(void)
{
  intptr_t res = 0;
  *(uint8_t*)0x20000740 = 0x12;
  *(uint8_t*)0x20000741 = 1;
  *(uint16_t*)0x20000742 = 0x200;
  *(uint8_t*)0x20000744 = -1;
  *(uint8_t*)0x20000745 = -1;
  *(uint8_t*)0x20000746 = -1;
  *(uint8_t*)0x20000747 = 0x40;
  *(uint16_t*)0x20000748 = 0xcf3;
  *(uint16_t*)0x2000074a = 0x9271;
  *(uint16_t*)0x2000074c = 0x108;
  *(uint8_t*)0x2000074e = 1;
  *(uint8_t*)0x2000074f = 2;
  *(uint8_t*)0x20000750 = 3;
  *(uint8_t*)0x20000751 = 0x60;
  *(uint8_t*)0x20000752 = 9;
  *(uint8_t*)0x20000753 = 2;
  *(uint16_t*)0x20000754 = 0x48;
  *(uint8_t*)0x20000756 = 1;
  *(uint8_t*)0x20000757 = 1;
  *(uint8_t*)0x20000758 = 0;
  *(uint8_t*)0x20000759 = 0x80;
  *(uint8_t*)0x2000075a = 0xfa;
  *(uint8_t*)0x2000075b = 9;
  *(uint8_t*)0x2000075c = 4;
  *(uint8_t*)0x2000075d = 0;
  *(uint8_t*)0x2000075e = 0;
  *(uint8_t*)0x2000075f = 6;
  *(uint8_t*)0x20000760 = -1;
  *(uint8_t*)0x20000761 = 0;
  *(uint8_t*)0x20000762 = 0;
  *(uint8_t*)0x20000763 = 0;
  *(uint8_t*)0x20000764 = 9;
  *(uint8_t*)0x20000765 = 5;
  *(uint8_t*)0x20000766 = 1;
  *(uint8_t*)0x20000767 = 2;
  *(uint16_t*)0x20000768 = 0x200;
  *(uint8_t*)0x2000076a = 0;
  *(uint8_t*)0x2000076b = 0;
  *(uint8_t*)0x2000076c = 0;
  *(uint8_t*)0x2000076d = 9;
  *(uint8_t*)0x2000076e = 5;
  *(uint8_t*)0x2000076f = 0x82;
  *(uint8_t*)0x20000770 = 2;
  *(uint16_t*)0x20000771 = 0x200;
  *(uint8_t*)0x20000773 = 0;
  *(uint8_t*)0x20000774 = 0;
  *(uint8_t*)0x20000775 = 0;
  *(uint8_t*)0x20000776 = 9;
  *(uint8_t*)0x20000777 = 5;
  *(uint8_t*)0x20000778 = 0x83;
  *(uint8_t*)0x20000779 = 3;
  *(uint16_t*)0x2000077a = 0x40;
  *(uint8_t*)0x2000077c = 1;
  *(uint8_t*)0x2000077d = 0;
  *(uint8_t*)0x2000077e = 0;
  *(uint8_t*)0x2000077f = 9;
  *(uint8_t*)0x20000780 = 5;
  *(uint8_t*)0x20000781 = 4;
  *(uint8_t*)0x20000782 = 3;
  *(uint16_t*)0x20000783 = 0x40;
  *(uint8_t*)0x20000785 = 1;
  *(uint8_t*)0x20000786 = 0;
  *(uint8_t*)0x20000787 = 0;
  *(uint8_t*)0x20000788 = 9;
  *(uint8_t*)0x20000789 = 5;
  *(uint8_t*)0x2000078a = 5;
  *(uint8_t*)0x2000078b = 2;
  *(uint16_t*)0x2000078c = 0x200;
  *(uint8_t*)0x2000078e = 0;
  *(uint8_t*)0x2000078f = 0;
  *(uint8_t*)0x20000790 = 0;
  *(uint8_t*)0x20000791 = 9;
  *(uint8_t*)0x20000792 = 5;
  *(uint8_t*)0x20000793 = 6;
  *(uint8_t*)0x20000794 = 2;
  *(uint16_t*)0x20000795 = 0x200;
  *(uint8_t*)0x20000797 = 0;
  *(uint8_t*)0x20000798 = 0;
  *(uint8_t*)0x20000799 = 0;
  res = -1;
  res = syz_usb_connect_ath9k(3, 0x5a, 0x20000740, 0);
  if (res != -1)
    r[0] = res;
  *(uint8_t*)0x20000140 = 0;
  *(uint8_t*)0x20000141 = 0;
  *(uint16_t*)0x20000142 = htobe16(8);
  memcpy((void*)0x20000144, "\000Z\000\000", 4);
  *(uint16_t*)0x20000148 = htobe16(1);
  *(uint16_t*)0x2000014a = htobe16(0);
  *(uint16_t*)0x2000014c = htobe16(0);
  *(uint8_t*)0x2000014e = 0;
  *(uint8_t*)0x2000014f = 0;
  syz_usb_ep_write(r[0], 0x83, 0x10, 0x20000140);
  *(uint32_t*)0x20000180 = 3;
  *(uint32_t*)0x20000184 = 0x1000;
  *(uint64_t*)0x20000188 = 0x200007c0;
  memcpy(
      (void*)0x200007c0,
      "\x5e\xfb\xf8\xff\xa6\x09\x6f\xba\x57\xa9\x5a\x79\x30\x20\x1e\x76\x8c\xaa"
      "\xf4\xb7\xb8\x61\xcc\x3b\xc8\x55\xcf\x08\x0a\xae\xba\x11\x4e\xcc\x22\x96"
      "\x0d\xe6\x74\x4c\x26\xed\xac\xb8\xb7\x8b\xb5\x69\x7b\x89\x84\xb1\x66\xb2"
      "\x56\xa4\xde\xb4\x5f\x2f\xcb\x8b\x72\xe1\x61\xe0\xce\x36\x7a\x81\xdb\xec"
      "\x07\x81\xdd\xb8\x1c\x77\xb1\x50\x51\x3d\x41\xda\x91\xff\xd4\xfd\x0f\xc7"
      "\x35\xe6\x94\x8a\x8e\x8d\xf5\x9d\x69\xa1\x83\x3f\x24\x69\x6f\x4e\xd1\x31"
      "\xbb\x86\xb9\x7e\x81\x13\x93\x7d\xc2\xb6\xa7\x67\x34\x62\xdd\xc3\xe2\xba"
      "\x5a\xb1\x09\x8d\x90\xc5\xf3\x7b\xc0\xfd\x29\x68\xea\xa5\x6e\x6c\x3a\xae"
      "\xa2\xa3\x82\xb9\x60\x44\x3c\xcf\x61\xef\x12\x70\x81\x8c\xae\x4f\xae\x97"
      "\xa0\xfd\x32\x92\x5b\x72\x88\x63\xa8\x61\x85\xe5\x48\x55\xbc\x8c\x86\xee"
      "\x65\xf8\x46\xfe\x33\xaf\x24\x38\x4b\x51\xcd\x54\xe5\x6b\xf2\x2d\x5e\xfe"
      "\x48\xe1\xe9\x15\xe5\xc2\x63\x1d\x2c\xf2\x58\x09\x3c\x42\xe9\xac\x69\x85"
      "\xa7\x8c\xf0\x53\xd1\xea\xdc\x32\xc9\x22\x04\xc9\xbb\x0c\x6f\xd6\xa5\xe8"
      "\xa5\x10\x01\x7f\xb1\x6f\x8a\x60\x79\xf2\x64\x2c\xb3\x00\x9b\x28\xa2\xaf"
      "\xbb\xbf\x23\x21\x1c\xb4\xab\xf3\xc5\xa9\x6f\x77\x0a\xa4\x69\x89\x77\x30"
      "\x08\xdb\x5e\xb1\xfc\x37\xd7\x7d\xdc\x91\x24\x2d\x01\xad\x22\xa0\xdb\x1d"
      "\xb1\xc1\xe8\x74\x0a\xc5\x0f\x97\x8c\x3c\x3f\x1b\xa3\x53\x3d\x5a\xf0\xc4"
      "\x03\x88\xb1\x72\xda\xe3\x25\x85\xe3\x54\x88\xff\x18\x2f\x31\x0a\x7b\x52"
      "\x18\xdc\x4c\xd5\x7c\x63\x22\x50\x2c\x24\x92\x8b\xe4\x44\xf3\x36\x3c\xbe"
      "\xf3\x43\x46\x78\xc5\xc7\x1d\x5c\xbc\x1c\xef\xf2\x1c\x43\xf7\x3d\x6c\x9a"
      "\x63\x05\xa9\xd9\x92\xad\x60\x48\x76\xf1\x95\xb9\x44\x64\x04\x12\x4c\x13"
      "\x45\xe9\x48\x73\xf9\x6f\x79\x02\xc9\xdc\x1c\x2d\x06\xfe\x2f\xc2\xc0\x42"
      "\x12\xaa\xb2\xd7\xf6\xa7\xf2\xcf\x89\x51\x8d\x4c\xc1\xe8\x8c\x2e\x1c\xee"
      "\x87\x4c\x34\x3e\x07\x27\xcb\x8f\x6a\xa3\x90\x00\x75\xf3\x76\x8b\xe3\x2b"
      "\x1c\x27\xec\x1c\x2d\x02\xf2\x24\x47\x08\x43\x52\xdc\x1f\x05\xe7\x39\xa6"
      "\xc5\xea\x68\xb7\xdd\x87\xbc\x8f\x15\x89\xe3\x4b\x4f\x57\xf1\xfb\x83\x0a"
      "\x74\xe4\xd8\xa6\x75\x7e\xfb\xfe\x71\x38\xbc\xf6\x42\xc3\xd5\x40\x4d\x85"
      "\x28\xa9\x92\x20\xf1\x58\x13\x3b\x14\x39\x83\x6f\x95\xa9\x46\xf5\x5c\x92"
      "\x2c\xae\x63\xf1\xf7\x46\xe4\x3f\x1c\xf2\x0f\x2d\xa9\xb1\xd5\xf9\x95\x9f"
      "\x59\xb5\xb3\xfe\xe4\xff\x29\xde\x45\xbd\xe2\x5b\xe2\x35\x0e\x62\x91\xc5"
      "\xa1\xc2\x7c\x7f\x43\xfb\x7a\x0c\x3c\x02\xa7\x84\x3b\xa4\xc7\xb0\x38\x6c"
      "\xe9\xbf\xa2\xb6\x56\x29\xf5\x3b\x02\x15\xe1\xef\x5e\xda\xa6\xf6\xb8\xba"
      "\x11\x31\xa4\xab\x4f\xc4\x3d\xff\x10\xfd\xbe\x96\x60\xec\x0e\x17\xb2\xbd"
      "\xd9\xec\x16\x71\x1b\x4b\xa2\x1a\xba\xf8\xea\x8a\x7f\xf1\x86\xdc\x43\x99"
      "\x40\xac\x79\x4b\xec\xa1\xf2\xf5\xe7\x3b\xd2\x48\xc6\xe4\xa9\xd5\xa4\xc3"
      "\x78\x35\xf0\x32\x0e\xb4\x87\x4c\xbf\xae\x14\x98\x87\xa3\x9f\xb9\xb0\x2a"
      "\x00\xf9\xcb\xfc\x74\xfe\xdc\x75\xf8\xfd\xb4\x2f\x8e\x73\xd1\xe4\xb3\x8e"
      "\xf2\x8c\xce\x85\x8b\x13\xb8\xc5\xde\x6d\x51\x64\x3d\x94\xce\x9e\xa1\xa9"
      "\xa6\xce\x3f\xd8\x8a\x75\x19\x98\x26\xa0\x8d\x7a\x6a\xc6\xe7\x0a\x7d\x04"
      "\x18\xd9\xc8\x85\xc9\x6f\x5b\x51\x6b\x61\x72\x19\x39\xff\xd8\x95\x9d\x87"
      "\xfb\xcd\x23\x87\xa1\x10\x1f\x11\xea\x99\x53\xf7\x44\x3e\xfd\x58\xe5\x81"
      "\xc1\x77\x86\x35\xe1\x02\x0e\x5f\x24\x69\x6a\xab\xe7\x5f\x99\xc5\x7c\x35"
      "\x85\x8a\x54\x89\x99\xa4\x91\x73\xe4\xc2\x8a\xc2\xd0\x24\x6d\xc8\x3b\xa2"
      "\x68\xe4\xf5\xd4\x10\xe8\xd7\x3f\x9b\xa0\xcc\xa3\xe0\x74\x25\xef\xb0\x09"
      "\xa9\xba\xd8\xa5\x07\x80\x53\xc9\x6b\x1b\x0b\xa4\xbb\x2a\x3d\xcc\x4b\xf4"
      "\x24\xf5\xe2\xcd\xb4\xd4\x88\x7f\x3d\x64\xb9\xa6\x88\x4e\x11\x2c\xf7\x99"
      "\x9b\x14\x9f\xb2\xe1\xa6\x7f\x11\x36\x65\x11\xa7\xfd\x87\xff\x5f\x5a\x57"
      "\x65\x42\x1b\x8b\x24\x08\xd7\x02\xc5\xd9\x27\xb2\xac\x7a\x56\x83\x0d\x2a"
      "\xcb\x5e\xb1\x9f\x96\x86\xe8\x26\xef\x0c\xa4\x31\x28\xf2\x65\xdd\xa2\x83"
      "\x14\x1a\x16\x1c\x3e\x9e\x79\xee\x4e\x14\x96\xc3\x58\x83\x0a\xaf\x59\xb4"
      "\x9a\xb4\x5b\x05\x72\x2f\x4e\xb1\x07\xc5\xa7\xaf\x73\x18\x21\x38\x16\x7a"
      "\x9c\xd6\xb0\xe3\x4e\x53\xfc\x8c\x2e\x0e\x80\x74\x50\xcc\x0c\xdb\x49\x4e"
      "\x48\xd5\xde\x1e\xb0\x61\x10\x70\x57\xac\xfb\x1a\x2c\x44\xa7\x84\x0c\x93"
      "\x65\xbe\x05\x63\xeb\x2f\xcb\xa6\xb8\x10\xd6\x93\x3a\xf0\x80\x14\x9f\x79"
      "\xb8\xdd\x4d\x8e\xca\x5e\x3f\x0e\xd4\x60\x64\xb8\x74\xb8\x02\x82\x72\xd2"
      "\x04\x16\x8a\xc4\xaa\x40\xb4\xa8\x0e\x4e\xd4\xab\xdc\x65\xa1\xf6\x16\xf3"
      "\x00\xd8\x51\x4a\xc8\x13\x82\xa2\xea\x9b\x8e\x41\x58\xf1\xf8\x1b\x9d\xa1"
      "\xed\x48\xc5\xef\x2d\xe5\x8a\x0e\x97\x07\xfe\xc8\xed\xa6\xea\xbd\x40\x9a"
      "\xca\x2d\xc7\xb0\xed\x39\x26\xec\x08\xdd\x27\xd5\x47\x91\x8e\x48\x2c\x02"
      "\x77\x6d\x98\xbe\x43\xbb\xf1\x56\xd8\x44\xc5\xee\x25\x80\x88\x94\xd1\xb3"
      "\x4b\x46\xf2\x96\x2d\x9f\xc3\xf7\x97\x5d\xbf\x8b\xe9\xe1\x4f\x1a\x6f\x03"
      "\x84\x0b\xd4\xaf\x4d\x22\x22\x77\x4f\xc6\x07\x92\xf7\x3d\x56\x61\x79\xf7"
      "\xa6\x3e\x97\x82\x34\x2a\xb8\xcd\xba\xad\xfc\x5a\x79\x81\x68\x5f\x79\x3a"
      "\x83\x37\x08\x10\x1b\x94\xfa\x78\xbb\xf7\x89\x81\xd1\x45\xf4\xa4\x72\xa8"
      "\xd9\x1d\x90\x51\x1d\xbe\xa1\x79\x42\x40\x9f\x86\x81\x7f\x82\xfb\x3a\x61"
      "\xd9\x4e\xef\x9c\xc9\x3d\xf4\xd0\x09\xf4\xa7\xc0\x7f\xb8\xe0\x17\xc3\x70"
      "\xfc\x53\x7a\xac\xd3\x6f\x79\xae\x40\x0b\xa3\xe1\xcc\x59\x61\x67\x3d\x28"
      "\x27\xeb\x69\x03\xce\xc9\xa9\x30\x52\x97\x4c\x9b\x45\x3b\xc6\xa6\x90\x94"
      "\x25\xff\x89\x4d\xf9\xd7\xab\xb2\x13\x75\x7b\x5d\xd4\x4e\xc9\x2a\x23\x8e"
      "\xc8\x26\xc6\x77\x8c\x62\x27\x51\x02\xdf\xc7\x84\x8a\x64\xb2\x40\xb5\x77"
      "\x80\x4e\x47\xfd\x14\x3e\xf4\x39\xb3\x86\x8c\xc1\xdd\xc6\x38\xab\xeb\x2d"
      "\x09\xce\xb8\xde\x46\xa2\xae\x05\xa7\x51\x41\x8c\x44\x35\x0f\x98\xca\x83"
      "\x90\xb7\x3a\x13\xe9\x53\x69\x98\xab\x72\x19\x15\x0c\x16\xa1\xb6\x2c\xb4"
      "\x2d\x9c\xeb\x36\x8f\x39\xc9\x26\x38\xff\x82\xa6\x64\x22\xa3\x6a\x18\x30"
      "\x58\x4b\x14\x61\x06\xeb\xb5\x87\xfa\xee\xaf\xbe\xc5\x86\x65\xac\xb6\x69"
      "\x96\xe0\x13\x6f\xaf\x5c\x41\x15\xfe\x5d\xbc\x14\x93\x44\x15\x3e\x6b\xe8"
      "\xbe\x00\x76\x68\xcd\x5f\x72\x1e\x47\x8f\x3f\x8b\x69\x6f\x77\xec\x11\x67"
      "\x4a\x50\x36\x42\xdf\x63\x26\x15\x9f\xde\xbd\x6b\xb6\xa5\x14\x51\x27\x6f"
      "\xe0\xcc\x04\xee\x52\x14\xb4\xd7\xbe\x38\x45\x06\xeb\xad\x76\xb3\x13\xa8"
      "\x79\xfa\x27\x16\x81\x49\xf7\xa5\x0c\xb2\xa5\x3a\xd9\x3a\x9a\x20\x32\x64"
      "\xa1\xba\x72\x0f\xb3\x00\x44\xc7\xc4\xf4\x30\x63\x4c\x0d\x02\x9b\x44\x05"
      "\x20\x9b\x73\xc1\x2d\xa2\x5f\x80\xea\xcf\x31\x4d\x35\x6f\x3f\x7e\xf8\xf7"
      "\xed\x26\x4f\x16\xf7\x0d\x35\xf7\xbb\x0e\x0e\xf5\x1b\x60\xb6\x5c\x58\x04"
      "\x45\x09\x82\x73\x13\x1f\x10\x52\x5b\xb6\x61\x6c\x29\x16\x11\x2f\x53\x3b"
      "\x5a\x71\x3f\xd0\xeb\x6d\x27\x00\x7a\x48\x8a\x18\x5a\x64\x5b\x3b\x47\x00"
      "\x94\xb1\x04\xae\x5d\xc7\x72\x64\x0a\x01\x14\xfc\xd5\xd5\x97\xbb\xe5\xe9"
      "\x0c\xfb\x9d\x61\x7a\xb4\xf8\x72\xe7\x56\x89\xb4\xe4\xa7\x4a\x4a\x98\xfa"
      "\xc7\x95\x29\x49\xc8\x10\xa7\x23\x43\xea\xad\x4b\xec\xd1\xf3\x59\xa5\x6b"
      "\x15\x6c\xc2\x01\xfc\x4f\xef\x03\xf1\xcc\xa8\xab\xd1\x86\xbc\xee\xe7\x4d"
      "\xab\xcd\xd8\x67\x9a\xe8\x0d\xe3\x51\x57\x7d\x10\xe1\xaf\x96\x17\xd0\x2e"
      "\xbf\x38\x0c\x81\x7b\xa1\xb1\x07\x4e\x3a\x31\x9c\xff\xa9\x5c\x59\x34\x43"
      "\x23\xf6\xf7\x56\x08\x75\x31\xbb\x06\x5c\xdb\x88\x29\x0a\xb9\x30\x20\x64"
      "\x26\x38\x53\x52\x2d\x5e\x17\x26\xf5\xb4\x5e\xcb\xe1\x35\xd8\x4e\x64\x58"
      "\x0d\x18\xc6\xb9\x11\xc9\xdd\x78\x95\x3d\x6b\x90\xeb\x90\x4c\xdd\x43\xa4"
      "\x53\xd7\x9f\x10\x58\xe7\xa2\x6b\x2a\x46\xc0\x7b\xb6\x29\x46\xad\xe9\xe8"
      "\x42\x54\xdb\xf1\x80\x7a\xa2\xab\x3d\x9b\x29\x3e\xeb\xd6\xa2\xe4\x8f\x37"
      "\xc5\xfc\xd2\xdb\x48\x6f\x1b\xa7\x23\xc8\xe0\x63\x0a\xb4\x85\x3e\x7f\x5b"
      "\x12\xf3\x70\xa8\x1d\xd8\x98\xc9\x53\x29\x9c\x2e\xb7\xe7\x12\xab\xb2\xd3"
      "\x1a\xf9\x7e\x88\x49\x22\xfa\x94\x9f\x93\x4d\x96\x17\x3b\xbb\x18\xb2\xdb"
      "\x6d\x48\x0c\x63\x65\xe7\x90\x6b\x26\x08\x18\x3d\xb9\x86\x6c\xd4\x10\x2f"
      "\xaa\xc1\xaf\xd4\xbc\xa8\x8f\x29\x21\xd3\xcc\x48\x29\x3b\xe8\x3e\xd8\x65"
      "\x85\x8e\x19\x5f\x93\xea\xfc\xc0\xf0\xbf\x19\x77\xeb\xaf\xb3\x6e\xf5\x44"
      "\x22\x44\xac\xdb\x0a\xa5\xa6\x9c\x5e\x70\x4e\x67\x78\x75\x71\xb2\x49\x80"
      "\xbb\xcc\xbd\x17\x4c\x8a\x86\x87\xb4\xa1\x43\xa6\x43\x29\xfa\x19\x84\xd1"
      "\x2d\xdb\x86\x5f\x54\x65\x29\x78\xae\x45\x8e\x3c\x84\x87\xdf\x9a\x8d\xdd"
      "\xb9\x7f\x33\x67\x89\x4e\x0d\xc0\xd7\xc0\x9f\x19\xbd\xc1\x53\x39\xbd\x46"
      "\xac\x9e\xdc\xcf\x68\x10\x6c\x15\x8c\xd2\x72\x33\x11\x08\x25\x15\x41\x48"
      "\x6a\xe9\x8b\x5f\x37\xd6\xf8\x92\x80\xbb\x91\x0e\xe5\xb7\x17\xf6\x96\xdf"
      "\x3a\x1a\xe0\x08\x06\x75\x77\xd7\x4f\x43\x25\x4b\xa7\x02\x70\xff\x00\xfc"
      "\x3a\x85\xb9\x51\x35\x5c\x24\xec\x2c\xb8\xa9\x96\x2f\x7e\x7c\x2d\x92\x14"
      "\x0d\x5b\x06\x8a\xe3\x1b\x7c\xea\xea\x1a\x97\x4f\x02\x73\x8f\x22\x18\x82"
      "\x47\xb5\x4c\x65\xdb\x90\x46\xff\x15\x30\xf8\x4b\x37\xc1\x2f\x0e\xa3\xd8"
      "\x53\x34\x32\xd1\x2c\xb5\xaf\x09\x85\x0e\x7d\x67\xd1\x15\x29\xdf\xfe\x94"
      "\xf4\xa9\x79\x26\xac\x24\xc2\x22\x5c\x94\xb4\xd1\xf7\xef\x50\x8a\x4b\x6e"
      "\x18\xf6\xa3\x31\x3c\x3c\xc7\xb2\xf4\x93\x06\x6a\x0d\x39\xd8\x2c\x48\x9a"
      "\x76\x70\xaf\x94\x91\xe1\x22\xf2\x17\xcf\xa7\x1a\xca\xb9\x6e\x78\x52\xe0"
      "\x4c\x0e\x5c\x41\x9d\x27\x54\xae\x4b\xb2\x1c\x48\xc4\x5e\x80\x6e\x22\xc7"
      "\x8e\x05\x96\x7d\xfa\x0e\x47\x33\xbb\xb8\xcc\xb2\xac\xa8\xd8\xb8\x46\x5d"
      "\x1f\x70\x80\x35\x15\x47\x30\xa6\xee\xe1\xc3\xfb\xa2\xd8\x58\x47\xd8\x57"
      "\xe1\xf6\x36\x38\xdc\x9b\x5c\x29\x3a\xc0\x33\x94\x2e\x9b\x38\x22\xe9\x5a"
      "\x4f\x86\x4f\xa1\xd6\xbd\x1b\x6e\xf6\x58\x0b\x6f\xbb\x67\xae\xe7\x0b\x1c"
      "\x49\x65\x69\xf0\x88\x89\x1a\x54\xe2\x5f\x6e\x31\x3e\x87\x9f\xd4\x0a\x22"
      "\x65\x30\x4b\x5b\xb5\x34\x0a\x09\x5c\xb5\x81\x67\x08\x3d\xdc\xbd\x1e\xb2"
      "\xde\xa4\xc2\x8c\x71\x5e\x18\xe8\x24\x0e\xee\x20\x71\xe4\x83\xb4\x83\xeb"
      "\xa1\xb1\x04\x89\xc0\xea\xed\x34\x05\x81\x46\x60\xfb\xcd\x8c\x26\xd5\x84"
      "\xa2\xc3\xcf\x13\xb8\xe2\x12\x0d\x26\x36\x1a\x0a\x7e\xbe\x87\x56\xc5\xbd"
      "\x80\x30\xa9\x3d\x6a\xab\x31\xbd\xc6\x1f\x4e\x79\x88\x06\x63\xfe\x7a\x41"
      "\xd8\x80\x51\xe8\x72\x9e\x61\x18\x45\xfc\xe7\xc9\xb3\xd0\x3e\x70\x25\x82"
      "\xc6\xa0\x00\x1f\xef\x3a\xa1\x63\x4e\x09\xd0\x46\x7d\xf7\x26\xd2\xe0\xd0"
      "\x05\xed\x19\x56\x91\xcc\x70\x28\x13\x6a\x96\x84\xca\xcc\x67\xe0\x14\x21"
      "\x9b\x64\x41\x9a\x38\x90\xf8\x9b\x95\xa7\x31\x97\x2a\xb9\x0e\x3a\x62\x8c"
      "\x50\xeb\xa9\xa0\x37\xf8\x6f\x55\x0f\x66\x59\xfd\x86\x36\x42\x43\xe6\xca"
      "\x90\x1d\x5b\x2d\x98\xe4\x14\x12\x49\x03\x4c\x6e\x93\x39\xfb\xb8\x0c\x3e"
      "\xa0\xd7\xc8\x46\x79\x99\x73\xce\xce\x9c\x7b\xff\x10\x6e\xbd\x51\xac\x15"
      "\xf0\x67\x81\x03\xca\x02\x80\x06\xd7\x44\x68\x13\x25\xb9\x22\x48\xfa\xcb"
      "\x0c\xe5\x1a\x40\x46\x68\x18\xc1\x6c\xcf\xdc\xeb\x9c\x2d\xb3\x68\x42\xb9"
      "\x8d\xb1\xb9\xa8\xd5\xb8\x57\x00\xff\x8c\x06\x2b\xe0\x2a\xfe\xfc\x9f\xec"
      "\x5f\x90\xa9\x19\xd2\x8f\x02\xf9\x5d\x04\x23\xe1\x86\xaf\x43\x8f\x9c\x30"
      "\x22\x48\x2a\x8d\xe9\x51\xc8\xf6\xe5\xf7\x83\xb2\xeb\xa8\x9f\xa4\x4c\x0c"
      "\x02\x91\xac\x78\x72\xa4\xa2\x7d\xac\x41\x6d\xc3\xc7\xf3\xfe\xd8\x9d\xf5"
      "\x37\x41\x99\x2e\x96\x41\x46\xca\xeb\x38\x22\x67\x7e\x84\xf4\x0a\x1d\xbf"
      "\x2c\xbd\x4f\x01\xeb\x3b\x4b\x4f\x62\x49\xb3\x5d\xfe\x88\x93\x68\x0f\x6a"
      "\x73\xf1\x18\x27\xc3\x76\x33\x19\xa0\xd1\x17\x46\xf8\x22\x4f\x6d\x21\x74"
      "\xcd\x4a\x6e\xf2\x58\xa9\xb6\x1f\xb8\x1e\x90\xe0\x1d\xdd\xa2\x83\x82\x09"
      "\xee\x5d\xbb\xef\x08\xb1\xa6\x94\x3f\xff\x4a\x2b\xed\xde\x3a\x17\x31\x43"
      "\x71\x5b\x20\xb0\x94\x3a\xe5\x70\x51\x28\xaa\x39\x7f\x84\xcc\x5c\x8a\x3a"
      "\xf0\x11\x95\xd6\xfa\x26\x07\x09\x0d\x98\x34\x0d\xfb\x4e\xa6\x00\x5d\xef"
      "\x67\xa9\xec\xec\xb2\x10\xff\x90\xd3\x64\x9d\x94\x71\x65\x64\x36\x6b\x38"
      "\xf5\xd4\xf0\x94\x6a\xce\xb0\x86\xd2\x4c\xfa\x16\x37\xf1\x6f\xc0\x02\x4e"
      "\x32\xce\x08\x07\x36\x28\x1e\x95\xbb\xef\x7f\x2a\x24\xb4\x21\x81\xfa\xbf"
      "\x6f\x4e\x79\x57\x98\x36\x89\x0a\xc6\x99\x2f\x8f\x96\x6a\xf1\x33\xab\xad"
      "\x76\x8a\xed\x49\x69\x85\x5b\x82\x61\x30\xb9\x45\xe9\x26\x9c\x61\x60\x13"
      "\x43\xcf\x92\x4d\x71\x6c\x15\x74\x68\x5a\x41\x35\x5c\x04\xd8\xbc\xe7\x1f"
      "\x2a\xf8\x59\x5d\x08\x5e\x21\x17\xed\x01\x18\xce\x52\xd2\x39\x3b\x49\x76"
      "\x62\x68\x7b\xf9\xea\xb7\xe7\x2e\x0b\x51\x65\xb7\x5d\xb6\x28\x31\xe3\x86"
      "\x61\xb8\x49\x19\xa1\x08\x60\xd5\xc9\xe6\x9f\xf5\x5a\x87\x98\xca\xe0\xa9"
      "\x3e\x28\xc8\x89\x73\xd1\x69\xf4\x79\x27\x0d\x81\xfb\x91\x01\xc1\x15\x05"
      "\xc6\x27\x52\x98\x00\x06\x47\x35\x5a\xb7\xcd\x24\xbd\xb8\xf8\xfd\xab\x0f"
      "\x58\x0f\xa8\xd3\xcc\xb5\x53\x54\x77\x42\x45\x8e\xa2\x32\xa4\xed\xf1\x5a"
      "\x65\x94\x17\x14\x93\xd5\xfa\x86\x70\x2d\xea\x05\xbc\xca\x5c\x97\x1b\xa5"
      "\xc3\x62\x00\x37\x7a\x6e\x2a\x1c\x40\x49\x6e\xcb\x69\x82\xba\xd0\x6c\x3e"
      "\xfa\xec\x53\x36\x0e\x7d\xa0\xad\xf7\x46\x79\x33\x1a\xfb\xae\xfb\x6e\x96"
      "\x3a\xfe\x52\xb5\xb2\xbd\x32\x2f\x08\x25\x63\xb4\x35\xa2\x82\x8b\xbb\xf6"
      "\x03\xdb\x60\x08\x3f\x87\x19\x35\x9a\x18\x67\xe6\x6d\x96\x7a\x78\x8c\xa8"
      "\x50\xfb\xe9\xc8\x76\x39\x9e\x60\xe2\x2c\xd0\x1e\x7b\xd0\x15\xce\x54\x59"
      "\x7a\x69\x15\x7e\xb5\xd3\x54\x1f\x6d\xcb\x4d\xad\x63\xc0\xac\xf2\x98\x8a"
      "\x17\xbf\xc0\xc0\x8d\x39\xb7\xfd\xbf\x56\x3b\x6d\x6f\x59\x1d\xb1\x6d\x15"
      "\xfa\xd3\xe2\x11\x6c\x0d\x4c\x82\xdb\xd2\xc5\x14\x70\x31\x9d\xdd\x08\xa2"
      "\xbf\x68\x26\x02\x3d\xc1\x71\x2d\x17\x44\x5f\xe7\xcc\x25\xb4\x6c\x12\x7f"
      "\xa3\x62\x37\xcf\x37\x58\xe4\x86\xe5\x9a\x96\x4d\x0b\xf2\x69\x16\x5e\xfe"
      "\xe9\x3b\x87\x61\x45\x50\x44\x81\x32\x5f\xd1\x69\xd2\xfe\x85\x04\xa1\x6a"
      "\x5a\xe2\xa3\x9c\x2d\xeb\x6a\xf9\x80\xac\x83\x15\x58\x2f\xc9\x26\x1f\xea"
      "\x12\xdd\xfb\xac\x1f\xd6\x4b\xeb\xaf\xe7\xda\xa7\xc3\xd0\xb5\x6a\x30\x6b"
      "\xa1\x4e\x8d\x05\x51\x15\x96\x94\xa8\x51\x2c\x15\x38\x7c\xcf\x3b\x61\x3b"
      "\x2e\x38\x25\x50\xcd\x39\x7c\x12\x5a\xee\x91\x8d\xec\x16\xc3\x0c\xcb\x47"
      "\xd2\x67\xf5\x26\xab\xb3\x94\x78\xf7\xbe\x85\x50\xb4\xe2\xbd\x81\xaa\x7e"
      "\x46\xa0\x57\x9a\xbd\x6a\x7c\x07\x9f\xf0\x1a\x19\xba\x47\x7d\x89\xee\x06"
      "\xa5\x24\xb5\xf3\x1d\xe2\x96\xcf\x9b\xd4\xb2\x8a\x2f\x51\x12\xf0\x92\x8a"
      "\x3d\x62\x8a\x42\xda\xaa\x34\x2c\x65\x53\x4d\xcb\x5b\xd8\x41\x8e\x46\x0e"
      "\xb2\x72\x18\xa1\x23\x94\x01\xf5\xbd\x6a\xbd\x6d\x67\xc0\x2f\x11\xa7\x0f"
      "\xf5\x5c\x62\x87\x01\x49\x8c\xb1\x22\xfb\x20\xca\xbb\xb5\x56\x50\xad\x5e"
      "\x03\x97\x1a\xeb\x23\x5d\x55\xff\x9e\x1c\x34\x2a\x8e\x30\x42\x60\xee\x87"
      "\x80\x1e\x9c\xcc\x20\xdc\x27\xa3\xff\xbc\x42\xdd\x20\xf8\xe3\x78\x38\xd4"
      "\x06\x26\x37\x7a\x57\xa5\x2c\x61\x76\x93\xaf\x12\x04\xcf\x36\x46\x7c\x4d"
      "\xa2\x9b\x8a\x6a\xfb\x67\x5e\xce\xc2\xd5\xba\x90\x48\x0d\xd7\xf8\x3c\xd3"
      "\x9c\xb9\x81\x4a\x6c\x40\xa7\x2e\x77\xe0\xe2\x92\x73\x14\x39\x65\x4b\xf7"
      "\x71\xb6\xde\xc2\x3d\xe4\xd1\x89\xf0\x42\xb6\x68\xcb\xae\x0e\xb1\x8d\xd2"
      "\x85\x40\x01\x00\xdf\x14\x7a\x71\xa9\x84\x26\xf8\x5e\x3c\x0f\x3f\xc9\x9f"
      "\x21\x17\x99\xac\xa0\xf3\xbc\xae\xcc\xbf\xc6\x8b\xd8\x8e\xcd\x82\x96\x70"
      "\x44\xc2\x10\xf8\x1e\xc4\x46\x27\xc1\x15\xdc\x3b\x98\xcf\xb6\xb5\xa0\x36"
      "\xdd\x34\x3b\x4b\x8f\x02\xa7\xa7\x45\x95\x39\x0c\xc3\x4b\x77\x07\x7b\xbd"
      "\x88\xf1\xb3\xa1\x57\x25\xbe\x7b\x22\x74\x04\x4b\x00\x72\x28\x63\x1a\x4a"
      "\x3e\x41\x5b\x1c\x67\xfb\x81\xbf\x15\x3a\xbc\x8c\x2f\x18\x1f\x46\x66\xa6"
      "\xc6\x8d\x11\xae\x8f\x75\x47\x96\x75\x90\xc3\x81\xf8\x10\x2e\x5b\x0f\xbb"
      "\xfd\x71\x2b\xf3\xbb\x87\x6d\x8c\x16\xbc\xc6\x2a\xa8\xb8\x59\xba\xf6\x3e"
      "\x8e\x47\xbd\xec\xa3\xdc\xba\x1c\x45\x3a\xac\x90\x91\x5b\xc9\x0d\x6a\x08"
      "\x0d\xdf\x8d\x0b\xbc\x7d\xa0\x58\x00\xd8\x8a\x5a\x13\x37\x06\xef\x39\x81"
      "\xe7\x07\xbd\x1a\x36\x03\xb3\x8d\x72\xa2\x1c\x8c\x64\x93\xd9\x0a\xc0\x59"
      "\xb1\xd7\x35\xe8\x53\x07\x98\xd3\x75\x42\x2f\xcb\xec\x2a\x7b\x19\x4e\xec"
      "\x1a\xd1\x6c\x10\x67\xd8\x17\x5e\x28\x0b\xc0\x5b\x5f\xd2\x50\x08\xce\x64"
      "\x32\xf3\xd1\x5b\x10\xbc\xb8\xdb\x9a\xc4\xe0\xe4\xf6\xdd\x66\x55\x26\xa5"
      "\x72\x98\x79\x4c\x89\xa4\xd6\xad\x15\x6f\x67\xf8\xe5\x75\xd0\xf2\xb0\x4b"
      "\x73\xfe\x00\x9d\x84\x61\xe7\xab\x3a\x2f\xde\xbc\x03\xca\x5a\x95\x0b\x46"
      "\x97\xae\x26\x07\xb2\x30\xfa\xab\xe6\x26\xc5\x2b\xbe\xb0\xc7\x60\xef\x12"
      "\xd2\xda\xf2\x76\x21\xe1\x61\xf1\xc2\xcb\x2b\x62\x80\x36\x1e\x3b\x6c\xe3"
      "\xa0\x0a\x30\x5e\xe1\xbe\x61\xe7\x32\x71\xce\x64\x7f\x4c\xea\xbf\xf8\x97"
      "\xdd\xc6\xa9\x37\xd9\x8d\x48\x1b\xf5\x74\xe5\x53\xe0\xa5\x9a\x8d\x77\x7a"
      "\x79\xb0\xde\xe6\x93\x87\x32\x9f\x78\x51\xfb\x77\x76\xeb\xc5\x55\x68\xec"
      "\x7f\xe3\xb8\x20\x7b\xa3\x3c\x7c\x8c\x0b\xa3\x41\xd7\x96\xe9\xee\x36\xda"
      "\x0e\xa4\x34\xf5\x2f\xb0\x43\x70\x6a\x2a\x0d\xc0\x3a\x0d\xcb\x00\x52\x17"
      "\x25\x73\x45\x2e\x38\xd7\x05\x5e\x23\x38\xa5\x33\x41\x51\xb4\x47\x4e\xe6"
      "\xf0\x00\xd8\xa9\xb4\x40\x95\xeb\xce\xb3\x49\x93\x63\xc8\xbc\x9d\x7a\xe0"
      "\x9a\x6d\xae\x4d\x5b\x0a\xe6\x91\xdb\xf5\x1c\xb9\xb1\xce\xfe\x7d\x35\xfc"
      "\x9e\xc2\x4f\x6f\x41\xf2\x56\xbb\xc8\xc8\xe5\x1c\x52\x25\x27\x4f\xb1\x7d"
      "\x62\xda\x9d\x3c\xcd\x8d\xda\x22\x8d\x6e\xae\xd5\x6a\xc3\xf2\x7a\xbe\x74"
      "\x66\x24\x63\xd1\x0f\x05\x86\x9f\xec\xfb\x3b\x88\x4b\x60\x02\x93\xa9\x86"
      "\x32\x4e\x49\x72\x54\xbc\x29\xaa\x9d\xba\x26\x4e\x43\x6d\x1e\x1d\xf0\x28"
      "\x97\xdd\xad\xe9\x91\xb0\xaf\x88\x30\x1e\xf2\xb7\x7c\x80\x57\x8e\x35\x56"
      "\xfd\x6a\x14\x5a\x83\xe0\x97\xfa\x3e\xd2\xa4\x22\xfa\x62\xe5\x3f\xfa\x33"
      "\xa0\x96\x41\x4a\xbb\xd5\x09\x95\xf6\x9a\x56\x0e\xc3\x9c\x19\x5f\xf8\x5b"
      "\x1f\x3d\x6c\x90\x4d\xe6\xc6\xac\x6d\x6f\x99\xbf\x44\x54\xa4\x81\x4c\xca"
      "\xd4\x72\x09\x86\x4a\xcf\x30\x37\xca\x57\x5a\xbf\x14\x06\x6b\x79\x52\x3a"
      "\x81\x34\x29\x45\x70\xa4\x72\x6b\x15\x00\x21\x0e\xc2\x3f\x39\x86\xe4\xe3"
      "\x19\xae\x13\x40\xf8\x95\x5c\x13\x72\xf2\x31\x2c\x41\x80\x75\x13\xe2\x79"
      "\xf0\xde\x82\x53\x39\x6d\x02\xf2\xfc\xbb\x77\xe5\xe8\x95\xb2\xed\xae\x22"
      "\x25\x11\x92\x47\xe8\x4a\x7a\x38\x4a\x2e\xc1\x3d\x82\xe3\x75\x9c\x6e\x1b"
      "\x43\xd0\xa5\x05\x3b\x95\x36\xe4\x58\xb4\x31\x35\x59\x0f\x20\x75\x77\x4c"
      "\x13\xc2\x77\x0f\xfe\x72\xcf\x54\x1a\x15",
      4096);
  syscall(__NR_ioctl, -1, 0x40104593, 0x20000180ul);
  *(uint8_t*)0x200005c0 = 0;
  *(uint8_t*)0x200005c1 = 0;
  *(uint16_t*)0x200005c2 = htobe16(0xa);
  memcpy((void*)0x200005c4, "\x2f\x65\xcc\x19", 4);
  *(uint16_t*)0x200005c8 = htobe16(3);
  *(uint16_t*)0x200005ca = htobe16(0);
  *(uint8_t*)0x200005cc = 0;
  *(uint8_t*)0x200005cd = 8;
  *(uint16_t*)0x200005ce = htobe16(0);
  *(uint8_t*)0x200005d0 = 0;
  *(uint8_t*)0x200005d1 = 0;
  syz_usb_ep_write(r[0], 0x83, 0x12, 0x200005c0);
  *(uint8_t*)0x20000040 = 0;
  *(uint8_t*)0x20000041 = 0;
  *(uint16_t*)0x20000042 = htobe16(0xa);
  memcpy((void*)0x20000044, "\x07\x12\x70\x6e", 4);
  *(uint16_t*)0x20000048 = htobe16(3);
  *(uint16_t*)0x2000004a = htobe16(0x100);
  *(uint8_t*)0x2000004c = 0;
  *(uint8_t*)0x2000004d = 0;
  *(uint16_t*)0x2000004e = htobe16(0);
  *(uint8_t*)0x20000050 = 0;
  *(uint8_t*)0x20000051 = 0;
  syz_usb_ep_write(r[0], 0x83, 0xffffffffffffff9c, 0x20000040);
}
int main(void)
{
  syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  loop();
  return 0;
}
