// https://syzkaller.appspot.com/bug?id=cabffad18eb74197f84871802fd2c5117b61febf
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>
#include <linux/usb/ch9.h>

static unsigned long long procid;

static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) &&
      (addr < prog_start || addr > prog_end)) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  {                                                                            \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    }                                                                          \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
  }

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i;
  for (i = 0; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG, 1000000);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

#define MAX_FDS 30

#define USB_MAX_IFACE_NUM 4
#define USB_MAX_EP_NUM 32
#define USB_MAX_FDS 6

struct usb_endpoint_index {
  struct usb_endpoint_descriptor desc;
  int handle;
};

struct usb_iface_index {
  struct usb_interface_descriptor* iface;
  uint8_t bInterfaceNumber;
  uint8_t bAlternateSetting;
  uint8_t bInterfaceClass;
  struct usb_endpoint_index eps[USB_MAX_EP_NUM];
  int eps_num;
};

struct usb_device_index {
  struct usb_device_descriptor* dev;
  struct usb_config_descriptor* config;
  uint8_t bDeviceClass;
  uint8_t bMaxPower;
  int config_length;
  struct usb_iface_index ifaces[USB_MAX_IFACE_NUM];
  int ifaces_num;
  int iface_cur;
};

struct usb_info {
  int fd;
  struct usb_device_index index;
};

static struct usb_info usb_devices[USB_MAX_FDS];
static int usb_devices_num;

static bool parse_usb_descriptor(const char* buffer, size_t length,
                                 struct usb_device_index* index)
{
  if (length < sizeof(*index->dev) + sizeof(*index->config))
    return false;
  memset(index, 0, sizeof(*index));
  index->dev = (struct usb_device_descriptor*)buffer;
  index->config = (struct usb_config_descriptor*)(buffer + sizeof(*index->dev));
  index->bDeviceClass = index->dev->bDeviceClass;
  index->bMaxPower = index->config->bMaxPower;
  index->config_length = length - sizeof(*index->dev);
  index->iface_cur = -1;
  size_t offset = 0;
  while (true) {
    if (offset + 1 >= length)
      break;
    uint8_t desc_length = buffer[offset];
    uint8_t desc_type = buffer[offset + 1];
    if (desc_length <= 2)
      break;
    if (offset + desc_length > length)
      break;
    if (desc_type == USB_DT_INTERFACE &&
        index->ifaces_num < USB_MAX_IFACE_NUM) {
      struct usb_interface_descriptor* iface =
          (struct usb_interface_descriptor*)(buffer + offset);
      index->ifaces[index->ifaces_num].iface = iface;
      index->ifaces[index->ifaces_num].bInterfaceNumber =
          iface->bInterfaceNumber;
      index->ifaces[index->ifaces_num].bAlternateSetting =
          iface->bAlternateSetting;
      index->ifaces[index->ifaces_num].bInterfaceClass = iface->bInterfaceClass;
      index->ifaces_num++;
    }
    if (desc_type == USB_DT_ENDPOINT && index->ifaces_num > 0) {
      struct usb_iface_index* iface = &index->ifaces[index->ifaces_num - 1];
      if (iface->eps_num < USB_MAX_EP_NUM) {
        memcpy(&iface->eps[iface->eps_num].desc, buffer + offset,
               sizeof(iface->eps[iface->eps_num].desc));
        iface->eps_num++;
      }
    }
    offset += desc_length;
  }
  return true;
}

static struct usb_device_index* add_usb_index(int fd, const char* dev,
                                              size_t dev_len)
{
  int i = __atomic_fetch_add(&usb_devices_num, 1, __ATOMIC_RELAXED);
  if (i >= USB_MAX_FDS)
    return NULL;
  int rv = 0;
  NONFAILING(rv = parse_usb_descriptor(dev, dev_len, &usb_devices[i].index));
  if (!rv)
    return NULL;
  __atomic_store_n(&usb_devices[i].fd, fd, __ATOMIC_RELEASE);
  return &usb_devices[i].index;
}

static struct usb_device_index* lookup_usb_index(int fd)
{
  int i;
  for (i = 0; i < USB_MAX_FDS; i++) {
    if (__atomic_load_n(&usb_devices[i].fd, __ATOMIC_ACQUIRE) == fd) {
      return &usb_devices[i].index;
    }
  }
  return NULL;
}

struct vusb_connect_string_descriptor {
  uint32_t len;
  char* str;
} __attribute__((packed));

struct vusb_connect_descriptors {
  uint32_t qual_len;
  char* qual;
  uint32_t bos_len;
  char* bos;
  uint32_t strs_len;
  struct vusb_connect_string_descriptor strs[0];
} __attribute__((packed));

static const char default_string[] = {8, USB_DT_STRING, 's', 0, 'y', 0, 'z', 0};

static const char default_lang_id[] = {4, USB_DT_STRING, 0x09, 0x04};

static bool
lookup_connect_response_in(int fd, const struct vusb_connect_descriptors* descs,
                           const struct usb_ctrlrequest* ctrl,
                           char** response_data, uint32_t* response_length)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  uint8_t str_idx;
  if (!index)
    return false;
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_GET_DESCRIPTOR:
      switch (ctrl->wValue >> 8) {
      case USB_DT_DEVICE:
        *response_data = (char*)index->dev;
        *response_length = sizeof(*index->dev);
        return true;
      case USB_DT_CONFIG:
        *response_data = (char*)index->config;
        *response_length = index->config_length;
        return true;
      case USB_DT_STRING:
        str_idx = (uint8_t)ctrl->wValue;
        if (descs && str_idx < descs->strs_len) {
          *response_data = descs->strs[str_idx].str;
          *response_length = descs->strs[str_idx].len;
          return true;
        }
        if (str_idx == 0) {
          *response_data = (char*)&default_lang_id[0];
          *response_length = default_lang_id[0];
          return true;
        }
        *response_data = (char*)&default_string[0];
        *response_length = default_string[0];
        return true;
      case USB_DT_BOS:
        *response_data = descs->bos;
        *response_length = descs->bos_len;
        return true;
      case USB_DT_DEVICE_QUALIFIER:
        if (!descs->qual) {
          struct usb_qualifier_descriptor* qual =
              (struct usb_qualifier_descriptor*)response_data;
          qual->bLength = sizeof(*qual);
          qual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;
          qual->bcdUSB = index->dev->bcdUSB;
          qual->bDeviceClass = index->dev->bDeviceClass;
          qual->bDeviceSubClass = index->dev->bDeviceSubClass;
          qual->bDeviceProtocol = index->dev->bDeviceProtocol;
          qual->bMaxPacketSize0 = index->dev->bMaxPacketSize0;
          qual->bNumConfigurations = index->dev->bNumConfigurations;
          qual->bRESERVED = 0;
          *response_length = sizeof(*qual);
          return true;
        }
        *response_data = descs->qual;
        *response_length = descs->qual_len;
        return true;
      default:
        break;
      }
      break;
    default:
      break;
    }
    break;
  default:
    break;
  }
  return false;
}

typedef bool (*lookup_connect_out_response_t)(
    int fd, const struct vusb_connect_descriptors* descs,
    const struct usb_ctrlrequest* ctrl, bool* done);

#define ATH9K_FIRMWARE_DOWNLOAD 0x30
#define ATH9K_FIRMWARE_DOWNLOAD_COMP 0x31

static bool lookup_connect_response_out_ath9k(
    int fd, const struct vusb_connect_descriptors* descs,
    const struct usb_ctrlrequest* ctrl, bool* done)
{
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_SET_CONFIGURATION:
      return true;
    default:
      break;
    }
    break;
  case USB_TYPE_VENDOR:
    switch (ctrl->bRequest) {
    case ATH9K_FIRMWARE_DOWNLOAD:
      return true;
    case ATH9K_FIRMWARE_DOWNLOAD_COMP:
      *done = true;
      return true;
    default:
      break;
    }
    break;
  }
  return false;
}

#define UDC_NAME_LENGTH_MAX 128

struct usb_raw_init {
  __u8 driver_name[UDC_NAME_LENGTH_MAX];
  __u8 device_name[UDC_NAME_LENGTH_MAX];
  __u8 speed;
};

enum usb_raw_event_type {
  USB_RAW_EVENT_INVALID = 0,
  USB_RAW_EVENT_CONNECT = 1,
  USB_RAW_EVENT_CONTROL = 2,
};

struct usb_raw_event {
  __u32 type;
  __u32 length;
  __u8 data[0];
};

struct usb_raw_ep_io {
  __u16 ep;
  __u16 flags;
  __u32 length;
  __u8 data[0];
};

#define USB_RAW_EPS_NUM_MAX 30
#define USB_RAW_EP_NAME_MAX 16
#define USB_RAW_EP_ADDR_ANY 0xff

struct usb_raw_ep_caps {
  __u32 type_control : 1;
  __u32 type_iso : 1;
  __u32 type_bulk : 1;
  __u32 type_int : 1;
  __u32 dir_in : 1;
  __u32 dir_out : 1;
};

struct usb_raw_ep_limits {
  __u16 maxpacket_limit;
  __u16 max_streams;
  __u32 reserved;
};

struct usb_raw_ep_info {
  __u8 name[USB_RAW_EP_NAME_MAX];
  __u32 addr;
  struct usb_raw_ep_caps caps;
  struct usb_raw_ep_limits limits;
};

struct usb_raw_eps_info {
  struct usb_raw_ep_info eps[USB_RAW_EPS_NUM_MAX];
};

#define USB_RAW_IOCTL_INIT _IOW('U', 0, struct usb_raw_init)
#define USB_RAW_IOCTL_RUN _IO('U', 1)
#define USB_RAW_IOCTL_EVENT_FETCH _IOR('U', 2, struct usb_raw_event)
#define USB_RAW_IOCTL_EP0_WRITE _IOW('U', 3, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP0_READ _IOWR('U', 4, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_ENABLE _IOW('U', 5, struct usb_endpoint_descriptor)
#define USB_RAW_IOCTL_EP_DISABLE _IOW('U', 6, __u32)
#define USB_RAW_IOCTL_EP_WRITE _IOW('U', 7, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_READ _IOWR('U', 8, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_CONFIGURE _IO('U', 9)
#define USB_RAW_IOCTL_VBUS_DRAW _IOW('U', 10, __u32)
#define USB_RAW_IOCTL_EPS_INFO _IOR('U', 11, struct usb_raw_eps_info)
#define USB_RAW_IOCTL_EP0_STALL _IO('U', 12)
#define USB_RAW_IOCTL_EP_SET_HALT _IOW('U', 13, __u32)
#define USB_RAW_IOCTL_EP_CLEAR_HALT _IOW('U', 14, __u32)
#define USB_RAW_IOCTL_EP_SET_WEDGE _IOW('U', 15, __u32)

static int usb_raw_open()
{
  return open("/dev/raw-gadget", O_RDWR);
}

static int usb_raw_init(int fd, uint32_t speed, const char* driver,
                        const char* device)
{
  struct usb_raw_init arg;
  strncpy((char*)&arg.driver_name[0], driver, sizeof(arg.driver_name));
  strncpy((char*)&arg.device_name[0], device, sizeof(arg.device_name));
  arg.speed = speed;
  return ioctl(fd, USB_RAW_IOCTL_INIT, &arg);
}

static int usb_raw_run(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_RUN, 0);
}

static int usb_raw_event_fetch(int fd, struct usb_raw_event* event)
{
  return ioctl(fd, USB_RAW_IOCTL_EVENT_FETCH, event);
}

static int usb_raw_ep0_write(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_WRITE, io);
}

static int usb_raw_ep0_read(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_READ, io);
}

static int usb_raw_ep_write(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_WRITE, io);
}

static int usb_raw_ep_enable(int fd, struct usb_endpoint_descriptor* desc)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_ENABLE, desc);
}

static int usb_raw_ep_disable(int fd, int ep)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_DISABLE, ep);
}

static int usb_raw_configure(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_CONFIGURE, 0);
}

static int usb_raw_vbus_draw(int fd, uint32_t power)
{
  return ioctl(fd, USB_RAW_IOCTL_VBUS_DRAW, power);
}

static int usb_raw_ep0_stall(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_STALL, 0);
}

static int lookup_endpoint(int fd, uint8_t bEndpointAddress)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  int ep;
  if (!index)
    return -1;
  if (index->iface_cur < 0)
    return -1;
  for (ep = 0; index->ifaces[index->iface_cur].eps_num; ep++)
    if (index->ifaces[index->iface_cur].eps[ep].desc.bEndpointAddress ==
        bEndpointAddress)
      return index->ifaces[index->iface_cur].eps[ep].handle;
  return -1;
}

static void set_interface(int fd, int n)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  int ep;
  if (!index)
    return;
  if (index->iface_cur >= 0 && index->iface_cur < index->ifaces_num) {
    for (ep = 0; ep < index->ifaces[index->iface_cur].eps_num; ep++) {
      int rv = usb_raw_ep_disable(
          fd, index->ifaces[index->iface_cur].eps[ep].handle);
      if (rv < 0) {
      } else {
      }
    }
  }
  if (n >= 0 && n < index->ifaces_num) {
    for (ep = 0; ep < index->ifaces[n].eps_num; ep++) {
      int rv = usb_raw_ep_enable(fd, &index->ifaces[n].eps[ep].desc);
      if (rv < 0) {
      } else {
        index->ifaces[n].eps[ep].handle = rv;
      }
    }
    index->iface_cur = n;
  }
}

static int configure_device(int fd)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return -1;
  int rv = usb_raw_vbus_draw(fd, index->bMaxPower);
  if (rv < 0) {
    return rv;
  }
  rv = usb_raw_configure(fd);
  if (rv < 0) {
    return rv;
  }
  set_interface(fd, 0);
  return 0;
}

#define USB_MAX_PACKET_SIZE 4096

struct usb_raw_control_event {
  struct usb_raw_event inner;
  struct usb_ctrlrequest ctrl;
  char data[USB_MAX_PACKET_SIZE];
};

struct usb_raw_ep_io_data {
  struct usb_raw_ep_io inner;
  char data[USB_MAX_PACKET_SIZE];
};

static volatile long
syz_usb_connect_impl(uint64_t speed, uint64_t dev_len, const char* dev,
                     const struct vusb_connect_descriptors* descs,
                     lookup_connect_out_response_t lookup_connect_response_out)
{
  if (!dev) {
    return -1;
  }
  int fd = usb_raw_open();
  if (fd < 0) {
    return fd;
  }
  if (fd >= MAX_FDS) {
    close(fd);
    return -1;
  }
  struct usb_device_index* index = add_usb_index(fd, dev, dev_len);
  if (!index) {
    return -1;
  }
  char device[32];
  sprintf(&device[0], "dummy_udc.%llu", procid);
  int rv = usb_raw_init(fd, speed, "dummy_udc", &device[0]);
  if (rv < 0) {
    return rv;
  }
  rv = usb_raw_run(fd);
  if (rv < 0) {
    return rv;
  }
  bool done = false;
  while (!done) {
    struct usb_raw_control_event event;
    event.inner.type = 0;
    event.inner.length = sizeof(event.ctrl);
    rv = usb_raw_event_fetch(fd, (struct usb_raw_event*)&event);
    if (rv < 0) {
      return rv;
    }
    if (event.inner.type != USB_RAW_EVENT_CONTROL)
      continue;
    char* response_data = NULL;
    uint32_t response_length = 0;
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      bool response_found = false;
      NONFAILING(response_found = lookup_connect_response_in(
                     fd, descs, &event.ctrl, &response_data, &response_length));
      if (!response_found) {
        usb_raw_ep0_stall(fd);
        continue;
      }
    } else {
      if (!lookup_connect_response_out(fd, descs, &event.ctrl, &done)) {
        usb_raw_ep0_stall(fd);
        continue;
      }
      response_data = NULL;
      response_length = event.ctrl.wLength;
    }
    if ((event.ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD &&
        event.ctrl.bRequest == USB_REQ_SET_CONFIGURATION) {
      rv = configure_device(fd);
      if (rv < 0) {
        return rv;
      }
    }
    struct usb_raw_ep_io_data response;
    response.inner.ep = 0;
    response.inner.flags = 0;
    if (response_length > sizeof(response.data))
      response_length = 0;
    if (event.ctrl.wLength < response_length)
      response_length = event.ctrl.wLength;
    response.inner.length = response_length;
    if (response_data)
      memcpy(&response.data[0], response_data, response_length);
    else
      memset(&response.data[0], 0, response_length);
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      rv = usb_raw_ep0_write(fd, (struct usb_raw_ep_io*)&response);
    } else {
      rv = usb_raw_ep0_read(fd, (struct usb_raw_ep_io*)&response);
    }
    if (rv < 0) {
      return rv;
    }
  }
  sleep_ms(200);
  return fd;
}

static volatile long syz_usb_connect_ath9k(volatile long a0, volatile long a1,
                                           volatile long a2, volatile long a3)
{
  uint64_t speed = a0;
  uint64_t dev_len = a1;
  const char* dev = (const char*)a2;
  const struct vusb_connect_descriptors* descs =
      (const struct vusb_connect_descriptors*)a3;
  return syz_usb_connect_impl(speed, dev_len, dev, descs,
                              &lookup_connect_response_out_ath9k);
}

static volatile long syz_usb_ep_write(volatile long a0, volatile long a1,
                                      volatile long a2, volatile long a3)
{
  int fd = a0;
  uint8_t ep = a1;
  uint32_t len = a2;
  char* data = (char*)a3;
  int ep_handle = lookup_endpoint(fd, ep);
  if (ep_handle < 0) {
    return -1;
  }
  struct usb_raw_ep_io_data io_data;
  io_data.inner.ep = ep_handle;
  io_data.inner.flags = 0;
  if (len > sizeof(io_data.data))
    len = sizeof(io_data.data);
  io_data.inner.length = len;
  NONFAILING(memcpy(&io_data.data[0], data, len));
  int rv = usb_raw_ep_write(fd, (struct usb_raw_ep_io*)&io_data);
  if (rv < 0) {
    return rv;
  }
  sleep_ms(200);
  return 0;
}

static volatile long syz_usb_disconnect(volatile long a0)
{
  int fd = a0;
  int rv = close(fd);
  sleep_ms(200);
  return rv;
}

static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
  if (a0 == 0xc || a0 == 0xb) {
    char buf[128];
    sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1,
            (uint8_t)a2);
    return open(buf, O_RDWR, 0);
  } else {
    char buf[1024];
    char* hash;
    NONFAILING(strncpy(buf, (char*)a0, sizeof(buf) - 1));
    buf[sizeof(buf) - 1] = 0;
    while ((hash = strchr(buf, '#'))) {
      *hash = '0' + (char)(a1 % 10);
      a1 /= 10;
    }
    return open(buf, a2, 0);
  }
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  int i;
  for (i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  int i, call, thread;
  int collide = 0;
again:
  for (call = 0; call < 11; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      if (collide && (call % 2) == 0)
        break;
      event_timedwait(&th->done,
                      45 + (call == 2 ? 3000 : 0) + (call == 4 ? 300 : 0) +
                          (call == 7 ? 300 : 0) + (call == 9 ? 300 : 0) +
                          (call == 10 ? 300 : 0));
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
  if (!collide) {
    collide = 1;
    goto again;
  }
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter;
  for (iter = 0;; iter++) {
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5 * 1000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[4] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,
                 0xffffffffffffffff};

void execute_call(int call)
{
  intptr_t res = 0;
  switch (call) {
  case 0:
    NONFAILING(memcpy((void*)0x20000000, "/dev/input/event#\000", 18));
    res = syz_open_dev(0x20000000, 0x22, 0x501000);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    syscall(__NR_ioctl, r[0], 0x80284504, 0x200000c0ul);
    break;
  case 2:
    NONFAILING(*(uint8_t*)0x20000240 = 0x12);
    NONFAILING(*(uint8_t*)0x20000241 = 1);
    NONFAILING(*(uint16_t*)0x20000242 = 0x200);
    NONFAILING(*(uint8_t*)0x20000244 = -1);
    NONFAILING(*(uint8_t*)0x20000245 = -1);
    NONFAILING(*(uint8_t*)0x20000246 = -1);
    NONFAILING(*(uint8_t*)0x20000247 = 0x40);
    NONFAILING(*(uint16_t*)0x20000248 = 0xcf3);
    NONFAILING(*(uint16_t*)0x2000024a = 0x9271);
    NONFAILING(*(uint16_t*)0x2000024c = 0x108);
    NONFAILING(*(uint8_t*)0x2000024e = 1);
    NONFAILING(*(uint8_t*)0x2000024f = 2);
    NONFAILING(*(uint8_t*)0x20000250 = 3);
    NONFAILING(*(uint8_t*)0x20000251 = 0x28);
    NONFAILING(*(uint8_t*)0x20000252 = 9);
    NONFAILING(*(uint8_t*)0x20000253 = 2);
    NONFAILING(*(uint16_t*)0x20000254 = 0x48);
    NONFAILING(*(uint8_t*)0x20000256 = 1);
    NONFAILING(*(uint8_t*)0x20000257 = 1);
    NONFAILING(*(uint8_t*)0x20000258 = 0);
    NONFAILING(*(uint8_t*)0x20000259 = 0x80);
    NONFAILING(*(uint8_t*)0x2000025a = 0xfa);
    NONFAILING(*(uint8_t*)0x2000025b = 9);
    NONFAILING(*(uint8_t*)0x2000025c = 4);
    NONFAILING(*(uint8_t*)0x2000025d = 0);
    NONFAILING(*(uint8_t*)0x2000025e = 0);
    NONFAILING(*(uint8_t*)0x2000025f = 6);
    NONFAILING(*(uint8_t*)0x20000260 = -1);
    NONFAILING(*(uint8_t*)0x20000261 = 0);
    NONFAILING(*(uint8_t*)0x20000262 = 0);
    NONFAILING(*(uint8_t*)0x20000263 = 0);
    NONFAILING(*(uint8_t*)0x20000264 = 9);
    NONFAILING(*(uint8_t*)0x20000265 = 5);
    NONFAILING(*(uint8_t*)0x20000266 = 1);
    NONFAILING(*(uint8_t*)0x20000267 = 2);
    NONFAILING(*(uint16_t*)0x20000268 = 0x200);
    NONFAILING(*(uint8_t*)0x2000026a = 0);
    NONFAILING(*(uint8_t*)0x2000026b = 0);
    NONFAILING(*(uint8_t*)0x2000026c = 0);
    NONFAILING(*(uint8_t*)0x2000026d = 9);
    NONFAILING(*(uint8_t*)0x2000026e = 5);
    NONFAILING(*(uint8_t*)0x2000026f = 0x82);
    NONFAILING(*(uint8_t*)0x20000270 = 2);
    NONFAILING(*(uint16_t*)0x20000271 = 0x200);
    NONFAILING(*(uint8_t*)0x20000273 = 0);
    NONFAILING(*(uint8_t*)0x20000274 = 0);
    NONFAILING(*(uint8_t*)0x20000275 = 0);
    NONFAILING(*(uint8_t*)0x20000276 = 9);
    NONFAILING(*(uint8_t*)0x20000277 = 5);
    NONFAILING(*(uint8_t*)0x20000278 = 0x83);
    NONFAILING(*(uint8_t*)0x20000279 = 3);
    NONFAILING(*(uint16_t*)0x2000027a = 0x40);
    NONFAILING(*(uint8_t*)0x2000027c = 1);
    NONFAILING(*(uint8_t*)0x2000027d = 0);
    NONFAILING(*(uint8_t*)0x2000027e = 0);
    NONFAILING(*(uint8_t*)0x2000027f = 9);
    NONFAILING(*(uint8_t*)0x20000280 = 5);
    NONFAILING(*(uint8_t*)0x20000281 = 4);
    NONFAILING(*(uint8_t*)0x20000282 = 3);
    NONFAILING(*(uint16_t*)0x20000283 = 0x40);
    NONFAILING(*(uint8_t*)0x20000285 = 1);
    NONFAILING(*(uint8_t*)0x20000286 = 0);
    NONFAILING(*(uint8_t*)0x20000287 = 0);
    NONFAILING(*(uint8_t*)0x20000288 = 9);
    NONFAILING(*(uint8_t*)0x20000289 = 5);
    NONFAILING(*(uint8_t*)0x2000028a = 5);
    NONFAILING(*(uint8_t*)0x2000028b = 2);
    NONFAILING(*(uint16_t*)0x2000028c = 0x200);
    NONFAILING(*(uint8_t*)0x2000028e = 0);
    NONFAILING(*(uint8_t*)0x2000028f = 0);
    NONFAILING(*(uint8_t*)0x20000290 = 0);
    NONFAILING(*(uint8_t*)0x20000291 = 9);
    NONFAILING(*(uint8_t*)0x20000292 = 5);
    NONFAILING(*(uint8_t*)0x20000293 = 6);
    NONFAILING(*(uint8_t*)0x20000294 = 2);
    NONFAILING(*(uint16_t*)0x20000295 = 0x200);
    NONFAILING(*(uint8_t*)0x20000297 = 0);
    NONFAILING(*(uint8_t*)0x20000298 = 0);
    NONFAILING(*(uint8_t*)0x20000299 = 0);
    res = syz_usb_connect_ath9k(3, 0x92, 0x20000240, 0);
    if (res != -1)
      r[1] = res;
    break;
  case 3:
    NONFAILING(memcpy((void*)0x20000000, "/dev/input/event#\000", 18));
    res = syz_open_dev(0x20000000, 0, 0);
    if (res != -1)
      r[2] = res;
    break;
  case 4:
    syz_usb_disconnect(r[2]);
    break;
  case 5:
    syscall(__NR_ioctl, r[2], 0x5501, 0ul);
    break;
  case 6:
    res = syz_open_dev(0, 0, 0);
    if (res != -1)
      r[3] = res;
    break;
  case 7:
    syz_usb_disconnect(r[3]);
    break;
  case 8:
    syscall(__NR_ioctl, r[3], 0x5501, 0ul);
    break;
  case 9:
    syz_usb_disconnect(-1);
    break;
  case 10:
    NONFAILING(memcpy(
        (void*)0x20001000,
        "\x04\x0d\x00\x4e\x9f\x6b\x54\xca\x3a\xe9\xa5\x85\xed\xfe\xd8\x8e\xd2"
        "\x01\xa4\x84\x1c\xab\x6b\xef\xaa\x42\x14\xfc\x61\x1e\x17\x70\xc9\xaa"
        "\xa3\x23\xdc\xde\xfd\xa5\x21\x73\x41\x88\x75\x51\x3d\x6d\x88\xf2\x1e"
        "\xb6\xa0\xb6\xa8\x55\x74\xd5\x29\x34\x63\xca\x44\xd0\xa6\xd4\x82\x3b"
        "\xf5\x67\x3f\x73\xa4\xde\x59\x9f\xc3\xd7\x5a\x8e\xbf\x95\xf1\xbc\x6d"
        "\x33\x93\xb8\xa9\xfc\x8a\xf0\x73\x70\xb4\x02\x2c\xfd\x6a\x1e\x31\x80"
        "\x0b\x50\x93\x05\x34\x2a\x79\xcf\x45\xbc\x87\x9e\x3d\x16\xd5\x27\xe1"
        "\x78\x42\xca\xc1\xb2\xc8\x42\x7b\xf1\x5e\x4c\x3f\x91\xb2\x6c\xdd\xef"
        "\x9f\xb1\xae\x89\xeb\x80\xda\x6a\x16\x05\xe6\xf0\xc0\xc7\x69\xce\x14"
        "\x23\x34\x97\x55\x6d\xa0\x84\x7e\x03\x30\xd5\x28\x4e\xdc\xd4\x84\xfc"
        "\x32\x70\x8c\x1c\xb2\x57\x9d\xb8\xd7\xe3\x29\xe8\x88\x6d\x10\x61\x28"
        "\x7e\x54\x66\x52\xe3\xdb\x46\x65\x04\xd0\x4f\xcc\xa0\x2f\x29\x9a\x73"
        "\xe1\x1e\xfd\xaf\xee\x56\x43\x55\xdb\xb2\x7e\xe7\x0a\x97\x42\x9f\x0c"
        "\xe0\x3a\x96\x33\x77\x99\xde\x36\xea\x26\xff\x96\x8a\x38\xad\x21\x48"
        "\x03\x9d\x12\x90\x67\x8c\x7d\xe8\x07\x05\x8b\x52\xd7\x62\x15\x79\xed"
        "\x57\x5a\x0b\x5f\x85\x56\x64\xa7\xf8\x3c\x8b\x45\x52\x2e\xbe\x3e\xff"
        "\xdb\x1a\xf9\x4b\xfa\x9d\x1c\x72\xd9\xbb\xc6\xd9\x4b\x79\x4b\xc2\x4d"
        "\x4d\x54\xe1\x3d\xf9\xad\xe2\x8e\x40\x04\x9d\xc1\x15\xe3\xd6\xd1\xc6"
        "\x45\x01\x8c\x2f\x99\x17\x29\xa0\xa3\x38\x31\xf0\xb3\x50\xa3\x82\x81"
        "\xa5\x06\x61\xfd\x60\x58\x26\xdc\x09\x04\x82\x0d\xb5\x42\xf2\xd8\xb0"
        "\x47\x77\x54\xea\x21\x9f\xc2\xc9\xc6\x5d\xb2\xd0\x2b\x76\x36\x8d\x61"
        "\x22\x01\x05\xb3\x41\xa9\x1e\xe5\x24\xe9\x4d\x74\x77\xff\xec\x1e\xb3"
        "\xf7\x8f\xb2\x1d\x33\xce\x8c\x20\x51\x35\x63\x41\xc2\x9a\x46\xd1\xaa"
        "\x00\x2c\xa3\xd0\x01\xfa\x42\x94\xc7\xb0\xd6\x23\x93\x52\x08\xed\xcc"
        "\xf5\x7e\x63\xa9\x7e\xca\x55\x69\xb1\x3e\x71\x1d\x72\x7a\x34\x85\x5b"
        "\xc2\x57\xe8\xb7\x23\x36\x76\x97\xfd\x6d\xdb\x09\x6b\xa9\xfc\xaf\xd6"
        "\xa9\xcb\xc7\xc8\x24\xd2\x1a\xc5\x54\x6d\x73\x5e\x7d\x14\xdc\xb2\xce"
        "\x96\x8d\xc8\x40\xc9\x6c\x0e\xfa\x5f\xee\x7f\x74\xf5\x8e\x81\x6a\x43"
        "\x42\xe7\x55\x0a\xc0\x46\x37\x7e\x48\x5e\x91\xae\xb4\x1d\x84\x4e\xfe"
        "\x0e\xc1\xf5\x96\xe6\xde\x94\x00\x7f\xac\x35\x85\x40\x9d\xcf\x2d\x78"
        "\xb6\x82\xb9\x15\x50\x35\x4f\x7f\x76\xf3\x4a\xf0\xba\xf0\x8e\xca\x02"
        "\x26\x3a\xaf\x36\xfc\x42\x7d\xa6\x33\x84\x07\x38\xb3\xeb\x2f\x3c\x32"
        "\x61\xee\x36\xe2\x57\xd5\x75\xa8\x8e\x82\x2a\xd0\x87\xcb\x2e\xac\xf3"
        "\xc1\x94\x0e\x96\xec\xe4\x2e\x20\x37\x61\x58\x95\xfb\xfe\xed\x04\x08"
        "\x42\x12\x22\x72\x76\x71\x59\xfc\x79\xfb\x39\x31\x97\xbc\x64\xb5\x66"
        "\xc4\xea\xe4\x05\xf3\x10\xd9\xae\x2b\x58\x5e\x48\x7b\xea\xac\x51\x78"
        "\x1c\x9b\x41\x8f\xd3\xc6\x25\xaf\xc7\x9f\xeb\x85\xd2\xcf\xfa\x52\x39"
        "\xcd\x12\xab\x47\xc7\x3e\x0a\x3d\xfd\x95\xb2\xf8\x18\x9a\xdc\xcb\x1c"
        "\x59\x19\x02\xf3\xa5\xa8\x20\xc9\x8d\xd9\x28\x81\xf8\x62\x51\xee\x27"
        "\x1e\xd5\x56\xd7\x33\xcc\x3f\x13\x3a\x9c\x32\x12\x19\xfb\x92\x7c\x91"
        "\xab\x4e\x1e\x27\x80\xd8\x58\x14\xfe\xa3\xfb\xdf\x50\x05\x33\xdd\x82"
        "\xe5\xb3\xcb\x59\x6b\x26\x63\x74\x01\x1b\x9e\x5b\x14\xbb\x3d\x02\xe3"
        "\x00\x22\x9b\x0d\x84\xab\x71\x58\xdb\x29\x94\x55\xd7\xc0\xdf\x9e\x64"
        "\x96\xd8\x09\xba\x9e\x15\xab\x9f\xad\xcc\xcc\x6e\x14\xa7\x3d\x0b\x56"
        "\xc4\x1d\x51\x6c\x0f\xa6\x36\xf8\x45\xb2\x2d\xa6\xd1\xe9\xb4\xda\xbb"
        "\x9f\x93\x3f\xf8\xc7\xbb\x06\xe3\xdc\x54\x30\x32\xb7\xb0\x2a\xec\xdf"
        "\xcf\x54\x3b\x90\xf9\x7a\x1e\xd8\xec\x86\x54\x72\x6f\x0f\x57\xe0\xae"
        "\xde\x6c\x9f\xb4\x06\x4c\x0f\x1d\xd6\x5d\x1e\x7a\x1a\xd1\xe9\xde\x2a"
        "\x89\xa5\x44\x11\x95\xd5\xbc\x80\x40\xd0\x21\x37\xb0\xc1\x62\x61\x23"
        "\x8d\xa0\xca\xf9\xbd\xec\x7a\xb9\x58\xe5\x83\xa1\x99\x98\x11\x7e\x6c"
        "\x95\xbf\xfa\x29\x77\x02\xc3\x30\x5e\x8e\x74\x26\x88\xf2\xc7\xc3\x3b"
        "\xbd\x29\x91\xdc\x41\x7f\x55\x2b\xdc\xe9\x96\x5d\x23\x96\xe4\xf8\x4b"
        "\x16\x39\x0e\x1b\x4a\x9a\xa0\x71\x28\x12\x62\x39\xd3\x27\xb0\x38\x4c"
        "\xe6\xb0\xa1\xeb\x4c\x64\x00\x1f\x20\xd3\x66\x78\x3d\x19\x27\x0b\x64"
        "\x33\x83\xba\xa6\x2c\xd7\x99\xd3\x19\x30\x5c\xa9\x26\xfe\xc4\x4e\x4e"
        "\x7f\x45\xb2\x60\xdc\xb5\xda\xf4\x56\x2d\x74\xe3\x59\x90\x4f\x7c\x9d"
        "\x31\x6e\x17\xe4\x84\x33\xa9\x84\x8a\x35\x31\x5d\x02\x51\x0a\xe6\x1f"
        "\x2b\x03\x98\xef\x42\xb9\x9b\xda\x74\xed\x39\x52\x53\xa4\x6e\x5a\x35"
        "\xb2\x8c\x43\xec\x42\xe7\xed\x34\xf2\x21\xfb\x3f\x55\x04\x64\xaf\x9f"
        "\x5e\xd9\x6c\xd0\x6a\x75\x39\x3f\xf2\xb5\xb9\x99\x63\x92\x0a\xe6\x89"
        "\x20\x19\x87\x02\xaa\x80\xc4\xa8\x72\x7a\x37\x88\x69\x28\xd1\x6c\xfd"
        "\xf2\x15\x2a\x3c\x65\xa2\xc4\x71\x8c\xd9\x03\x06\xdb\x83\x78\xf2\x10"
        "\xb2\xea\x19\x8f\xfe\x6c\xd8\x9c\xec\xc9\x38\x23\x09\xfd\xd7\x97\xaa"
        "\x1a\xed\x67\xff\xa3\x85\xc0\x04\xac\x58\xc8\x62\xbd\x01\x27\xf3\x9e"
        "\x71\xc0\x24\x8c\x70\x27\x83\x71\x9d\xc5\x1f\x20\x45\x72\xb6\xf9\x48"
        "\x01\x22\xa0\x49\xa5\xf3\x72\xba\x57\x28\x12\xfb\x57\x1b\x52\x27\xcf"
        "\xa2\xe5\x3e\x70\x1d\xc1\xf3\x7d\x21\xec\x59\x77\x4d\xc2\xa1\xfd\xc0"
        "\x7d\x3a\xd0\xc4\x60\x48\xb8\x09\x17\x0b\x26\xc9\xbf\x11\xcc\xc7\x50"
        "\x21\x8c\xe2\x9c\x9e\x75\x6a\x27\x3d\x57\xbe\x56\xfb\x67\x36\x47\x24"
        "\x30\x15\xd0\xd8\x4d\xa5\xfa\xfb\x1e\x0e\xd8\x6f\xbb\x50\x3c\x9a\x82"
        "\xd6\x8c\x7f\x33\xa1\x65\x08\x30\x8f\x7e\xe6\xc3\x6e\x10\xe2\xc9\x41"
        "\x5e\x59\xf3\xdd\xb8\x3a\xfe\x55\xdf\x03\x7e\xed\xff\xf5\xd2\xde\x4f"
        "\x63\x57\x1e\xde\x84\x70\xb8\x7c\x53\x85\x88\x6a\x2a\x14\xfd\x52\xad"
        "\x5e\x36\x41\x95\x85\xf4\xb1\xb3\x75\x50\xb8\x55\xac\x6c\xa7\x62\xff"
        "\xde\xd3\x56\xd1\xc5\x6a\x68\xe5\x96\x44\x10\x23\x5e\x2b\x5a\x3c\xe2"
        "\x6c\x9d\xec\xa7\x6c\x9c\x87\x53\x3a\x84\x31\x4b\x45\xb1\xb0\x32\x66"
        "\x62\x79\x2e\x85\xa6\xa6\x60\x14\xad\xa5\x58\xba\x6e\x1d\xf3\x2b\xd7"
        "\x23\x55\x89\x2b\x57\x03\xfe\xd9\x2c\xc9\xdc\xe7\x07\xfe\x1e\x85\x77"
        "\xbc\x24\x42\xf5\xb8\x93\xc1\xb0\x5c\xcc\x67\x9d\xba\xe2\x06\x91\x36"
        "\xc0\xc6\x8c\x14\xcc\x6f\xf4\xd4\xac\xe9\x63\x1e\x26\xdb\x52\x93\x03"
        "\x45\xa7\xb8\x69\x3f\x9e\xcd\x55\x5a\x52\x9f\xda\xbf\xd8\xb1\xaf\xc1"
        "\x03\x08\x05\x7d\x9e\xd6\x25\x29\x6b\x82\x14\xf2\xca\xab\x57\xe3\x20"
        "\x4a\xc0\xbd\x2b\xf7\x71\x34\x62\x8c\x78\xcd\x07\x55\xb9\x62\x56\x03"
        "\x0c\x8c\x58\xa6\x22\x7f\xc2\xd2\xdb\x01\xea\x51\x52\x65\x55\xde\x5c"
        "\x26\xde\x0c\x22\x6c\xc0\xac\x1b\xe8\xa0\xb9\xe2\xe3\x9b\x31\x2f\x04"
        "\x11\xaa\xcf\x29\xbd\xd0\x46\x93\x93\x30\x8d\x44\x05\x7b\x4a\x66\x12"
        "\x84\x99\xbd\xde\xc2\x15\x8c\x91\x23\x56\x42\x22\x80\x97\xa1\xbe\x0a"
        "\xc1\xb4\x85\xd0\xc7\x4f\x98\x21\xeb\xc3\xfb\xca\x03\x39\x03\xee\x29"
        "\xea\x03\xc8\x46\xf1\xe6\xa9\x8c\xa3\x03\xbd\xd4\x51\xda\xb5\xe9\x9e"
        "\x12\x5e\x56\x62\x69\xeb\x6d\xef\xcd\x9d\x5c\x1d\x88\x2f\x26\x4d\x8e"
        "\xd6\x77\xa6\x6f\x02\x22\x13\x8f\xe3\x5b\x92\x5e\xa2\xa3\xdd\xbb\x18"
        "\x98\x46\x92\x43\xd4\xe1\x80\xe0\xe4\x89\x00\xce\x7c\xb3\xc9\x95\xb6"
        "\x9a\x0c\xfd\xb9\xba\xd8\x03\x62\x66\xb8\x8c\x78\xe5\x72\xb6\xe3\x6d"
        "\x91\xbe\x30\xfd\x18\x91\x56\x51\x7d\x9b\x23\x12\x9a\x93\x41\x0a\xc8"
        "\x5e\xa9\x58\x35\x17\xb4\xd2\x16\xb4\xc1\x7b\x07\xfb\x93\x4e\xd7\xfc"
        "\xab\xfa\x05\x7e\xca\x85\x09\x57\x67\xb6\xd0\xed\x3f\x40\x62\x55\x3e"
        "\x84\x09\x50\x2b\xe4\x77\x27\x37\x7e\x2c\xbe\x9c\xcd\xd5\x02\xee\x14"
        "\x63\xc8\x79\x91\x57\xa1\xdd\x00\xac\xe4\x75\x24\xa4\xb5\xc5\xe6\xe2"
        "\x8d\x22\x5c\xaa\xf4\x2f\x95\x3e\x60\x64\x10\x78\x22\x42\x20\x61\xf9"
        "\x89\xcd\x91\x05\xfe\xeb\xe1\x80\xd3\x02\xf4\x89\xc2\x13\x89\xe2\x4f"
        "\x83\xaa\x4f\xaa\xe7\x8b\xe0\xf1\x8d\x9f\x99\x01\xe4\x05\x3c\x7b\xd5"
        "\xf7\x83\x65\x27\x51\xd0\xcb\x9e\xaf\xe6\x57\x5d\xe6\xea\xb9\xbb\x83"
        "\xd4\x78\x17\xde\xcb\x1b\x8c\xd9\x54\xc4\x53\x02\x9f\xbb\x67\x66\x1f"
        "\x53\x79\xbe\x9c\xdc\xed\x19\x58\x32\xb8\x8a\x4c\xec\x8f\x1b\x9f\x8c"
        "\x9e\x55\x2a\x05\x9e\xb0\x3c\xa4\xf3\xd9\x4b\xe2\x04\x67\xaa\x8e\x36"
        "\x44\x0c\x59\x75\x70\x42\x5b\x28\x40\x09\x37\xde\xf3\x14\xaf\x5a\xee"
        "\xf3\xdf\xa7\x35\xee\xe8\xe5\x81\xa0\xc6\x25\xd4\xbd\xfc\x97\xba\x73"
        "\x53\x96\x9c\x71\x46\x53\xce\x80\xd5\xb7\x68\x50\x32\xd4\xd1\xa7\x19"
        "\x26\x53\x89\x50\x3e\x42\x43\x2d\x77\x64\x0a\x39\xd6\x1b\xb3\x4c\x68"
        "\x61\x43\x72\xa5\x4e\xd1\xe6\x02\xbe\x24\xfd\x23\xf0\x6d\xe9\x12\xd0"
        "\x32\xc7\x8f\xef\x79\x27\xd7\x30\x41\x0f\xfd\x5e\x73\x99\x80\xf6\x43"
        "\x99\x33\x4d\x3f\x03\xfb\xd1\x4e\x09\x17\xe9\x36\x50\xb9\x6e\xe7\xfc"
        "\xe4\xe4\x1e\xfe\xd1\x3c\x31\x95\x54\x71\x57\x96\xc0\x22\x5e\x2d\x46"
        "\x18\x62\xa1\xa6\x5b\x33\x89\xe4\xfe\xca\x6a\xec\xe1\xc9\xf7\xba\x9f"
        "\x75\x4e\xd3\xb9\x76\x5c\xcd\x4f\x20\x67\xf6\x47\x38\xe8\xcf\x35\x2d"
        "\x69\x7d\xa2\x3d\xef\x62\x0a\x08\x5b\x26\x96\xf7\xcf\x6a\xcb\xf3\x22"
        "\xed\x51\xff\xaa\xfd\x87\x66\xa0\xca\x3f\x4f\x5a\x05\xed\x0a\xb9\x19"
        "\xab\x1c\xad\xd1\xa9\x66\xc2\x96\x4a\x06\xc9\x78\xa7\xa7\xa7\xe5\xb2"
        "\xf5\x09\xdb\xa4\x57\x99\x23\xe2\x92\xb6\x1b\x57\x0f\x2c\x13\x0e\x89"
        "\x9e\x16\x4b\x99\x9d\xc6\x3f\x6b\xbd\x88\x96\xe7\x73\xca\x9c\x3e\x0c"
        "\x4c\x4a\x70\x13\xa6\x57\x92\x20\x40\x25\x09\x4f\xf3\xae\x36\xd3\x4c"
        "\x07\x8a\xa0\xed\xa5\xfe\x87\x60\xa3\x8b\x6f\x4a\x63\x8d\xd2\x8e\x1d"
        "\x04\x7f\x71\xca\x8c\x30\x0b\x65\x19\x42\x84\x30\x95\x72\x81\x67\x82"
        "\xc3\xeb\xb8\x87\x35\x42\x1d\xd2\xb9\xd8\xa5\x91\x3b\x35\x9c\x18\x98"
        "\x00\xd0\xdf\x2c\x54\xfc\x17\x94\x07\x2d\x4d\xa9\x4b\x35\x71\x15\xb5"
        "\x54\xce\x33\x3f\x43\xaa\xee\x6f\x32\xe5\x71\x8b\xfa\x67\x13\x59\x15"
        "\xf2\x46\x56\x73\x4a\x0c\x86\x7a\xd3\x1f\xca\x16\xf7\xba\x2c\xc3\xcb"
        "\x25\x19\x13\x31\xc9\x04\xca\x4e\x02\xd2\xac\x9f\xd1\x5c\xb6\x28\xa2"
        "\xd4\xe7\x47\x85\xb6\x5d\xb4\x16\x07\x0a\x55\xc5\x28\x7f\x52\x5c\x46"
        "\xd7\x6f\xb4\x1f\x41\x7f\x45\x24\x77\x40\xd5\x32\x4a\x8a\x21\x2c\xd1"
        "\x53\x48\x65\x88\x7a\xf1\x63\xc8\xe3\x6f\x3e\xf2\xf3\x32\xed\x4e\xff"
        "\xb3\x72\xd5\x09\xf4\xbf\x4f\x49\x48\xbd\x7c\xd4\x7b\xd8\xbb\xf6\xd7"
        "\x99\x14\x88\x7e\xd7\xbc\x24\x33\x76\xcd\x2d\x64\xbe\xce\x66\x9c\x10"
        "\xbb\x89\x1c\x59\xb5\x1e\x8b\x67\x4b\x0f\xed\xab\x05\xca\x03\x51\xda"
        "\xe2\x8a\x47\x3b\x08\x67\x11\x46\x25\xb3\x18\x14\xe1\xdc\xbd\x19\x0c"
        "\x75\x7f\x96\x1f\x9c\x92\x50\x02\x7e\x47\x6b\xe5\x6a\x1d\x1a\x47\x26"
        "\x98\x2d\x3c\xfe\xb3\x3f\x59\x77\x25\x7c\xa0\xde\x46\x77\x14\x5e\x25"
        "\x1c\xd3\x29\x4f\xd4\xfd\x5b\x6e\x4a\x5d\x47\xf3\x1e\xdc\xa4\xb0\x59"
        "\x38\x91\x58\xc5\x8f\xe0\x33\xaa\x20\x80\xa9\xa3\x83\x0e\x30\x1e\x43"
        "\x6f\xdc\x43\xeb\x40\xc0\x8e\x0a\x61\xd5\x78\x31\x2f\x90\x5f\xa2\xb6"
        "\x48\x3c\x75\xd3\x06\xa0\xde\x1b\xfb\xb2\xbb\x84\xed\x58\x8f\xe6\x85"
        "\xf8\xb0\xf6\x73\x49\x7a\x89\xe2\x84\xe1\x40\x60\x7e\xd9\x0f\x49\x47"
        "\xfd\xd7\xc8\xf7\x39\x70\xe0\x43\x76\x6b\xda\x3e\x69\x8e\x56\x9d\x09"
        "\x1e\xf4\x99\xe9\xe8\x32\x54\xfc\x22\xd4\x79\xc6\xc6\x24\xe5\x07\x67"
        "\xe5\x17\x14\xbe\xe9\xc1\x96\x8b\x32\xba\x56\xbe\x26\x6b\xf2\xf8\xaa"
        "\x17\xbe\x71\x72\x43\x3e\xa2\x35\x91\x61\x53\xa5\x65\x11\x1a\x11\xa5"
        "\xf9\x2b\x78\xa7\x97\x78\x50\xd7\x62\x64\x65\x82\x8b\x26\x7f\x2d\x52"
        "\xfb\x85\xc1\xde\x20\xdd\xf6\x9f\x03\xb7\xa5\x78\xb8\x60\xf7\xb9\xc8"
        "\x13\xcb\xaa\xdd\xef\x2f\x52\xe4\x56\xd5\xfb\x73\x7c\x20\x70\x0d\xf8"
        "\x44\x45\x6d\x1b\x24\x20\x0b\x6c\x30\x43\xca\x8c\x21\x54\x9d\xbc\xc8"
        "\x36\xaf\xda\x67\xa2\xff\xaf\x49\x2e\xf4\xe9\x46\x7d\x5e\x7e\xfb\x08"
        "\x6f\x7f\x87\xf2\x46\x32\x8a\x1f\x6c\x4a\x3b\x8d\xd3\xbc\x1d\xc4\x44"
        "\xad\xfe\xcd\x06\x3d\x02\x9a\x5e\x64\x30\x36\xba\x8a\x63\x24\xe5\x08"
        "\x8b\xde\x6a\x73\x56\x9e\x75\x02\x15\xf1\x42\xf9\xe8\x27\xb7\x49\x07"
        "\xf3\x5c\x73\xeb\x7b\xaa\x37\x42\xd7\x34\x8e\x32\x42\x99\x5a\xca\xbc"
        "\x09\xaf\x48\x01\x73\xd6\xa7\x01\xd4\xfe\x13\x84\x7d\x7a\x00\x73\x48"
        "\x0e\xdb\x5d\xb5\xf8\x0f\xef\xd2\xca\x32\x85\x07\x8b\x78\xf8\x7d\x8c"
        "\x84\x7f\x10\x9a\xfe\xb8\xc4\xed\x6f\x56\x70\x5d\x65\xfe\x4b\xda\xd6"
        "\x78\x09\x3d\xe1\x39\xbd\xa0\x76\xb6\xf8\xd2\x5c\x02\x55\x46\xdd\xd3"
        "\x4c\x3c\xc6\x52\xc1\x8e\xc3\x8f\x32\xbf\xec\x12\xc6\x96\x04\x12\x5c"
        "\x63\xfc\xab\x1c\xeb\x37\x6b\xe2\xc0\xa4\xcf\x0c\x12\xf5\x9e\x32\x3b"
        "\x55\x06\x2d\xa3\x58\xb5\xc9\x9d\x9c\xa5\xba\x68\x98\xac\x68\x8d\x5b"
        "\xb2\x7f\xa5\x4c\xc6\x62\x8e\x47\x91\x8e\x27\x30\xa7\xa4\x39\xb1\xf6"
        "\x56\xc6\xd3\xc3\xb0\xcd\x7d\xc7\xfc\xb9\xdf\x48\x4c\x9f\xa7\x7c\x6f"
        "\x25\xc8\xe2\xb1\xe7\x44\xf4\x7b\x64\xa9\x31\x41\x4a\xeb\xd5\x8f\x4e"
        "\x77\x89\x69\xe5\x5b\xfa\x52\x55\xf7\x52\x6f\x9c\xe0\x69\xb9\x25\x37"
        "\xb9\x99\x78\xbe\xd7\xe1\xf1\xa2\x7b\x1c\x43\xe8\xfa\xf0\x33\x87\xef"
        "\xc7\xbf\xc9\xd0\xb0\xc2\x06\x06\xf7\x27\x41\x12\x27\xe8\x45\x9b\x9b"
        "\x00\xd1\x32\x44\xd4\x6a\x66\x59\x2c\xcb\xcd\x47\x75\x14\x80\x7e\x9a"
        "\x27\x17\x45\xb6\x83\x44\x4a\x7b\xcc\x18\x43\x1c\xdc\x73\x6e\xf2\x52"
        "\x6f\x04\xa2\x99\x9f\x94\xbf\x18\x1f\x95\x4e\x9b\xa7\xc1\x30\x7a\x67"
        "\x4e\x59\xb1\xc7\x49\xdf\xbc\x12\x1f\xee\x45\x39\x1c\xab\xb6\xff\x26"
        "\x88\x67\x53\x82\x32\x98\xee\x36\x49\xde\x91\xab\x24\x5e\xa1\x48\x51"
        "\x89\xdf\xed\x5a\xf7\x45\xac\xe3\xc9\x14\x06\xc9\x96\xf6\x57\x10\x6a"
        "\xb6\xab\xb3\x5e\x62\xe2\x61\x24\x85\xe7\x17\x15\xcc\xdf\x99\x31\x1d"
        "\x93\xda\x46\x28\x28\x3a\xbf\xf3\x20\x92\x62\xa3\x5b\x03\x0b\xd7\x19"
        "\xfc\x42\x18\xa7\xce\xa7\xbb\x58\x3a\x4f\x8a\x55\x05\xc2\xec\x12\x7b"
        "\xb6\xde\xe8\xb1\x85\x98\x15\x48\x77\xac\xef\x02\x65\x6f\x74\x5f\xc6"
        "\xcc\x93\xc3\x1c\xb7\xa1\xa1\xf8\xd5\xe7\x2c\x31\x4f\x9b\x3e\x23\x9a"
        "\x28\xaa\xc2\xf6\x98\x29\x93\x43\xec\xe2\xc1\x46\x2d\x63\xb4\x65\x66"
        "\x31\xbc\x53\x14\x6c\x3e\x02\x1b\xe6\x57\xa1\xdc\x59\x09\x5d\x48\xd3"
        "\x8d\x1a\xbf\xfa\x46\xae\xa0\xb8\x67\x11\x63\x14\x95\x0b\xe2\x61\xbd"
        "\xaf\x0a\x71\xda\x22\x3d\x64\x7d\xc9\xfb\x49\x95\xe4\x7f\xb1\x11\xa8"
        "\xcd\xbd\x5f\xcc\x87\x55\x3a\xbf\x66\xef\xe1\x09\x26\xf2\x92\x22\x8b"
        "\xcb\x53\xb6\x88\x19\xcf\xde\xe3\x7a\x9c\xd8\xc5\x8b\xba\x81\x9b\xa3"
        "\xbb\x32\x83\x76\xf9\x4e\xd0\x6b\xcf\x69\xd5\x0b\x53\x8c\x4e\xd6\x95"
        "\x51\x1f\x4d\xd1\x8e\x88\xda\x3d\x77\x9d\x90\x56\x0a\x27\x49\x22\xc0"
        "\x99\xd9\x79\x1e\x11\x84\x6d\x90\xce\x3c\xb3\x8a\xe6\x1b\x78\xbd\x3c"
        "\x28\x23\xc5\xb8\xb3\x69\x52\x79\x9a\x6e\xc3\x99\x37\x02\xc9\x15\x9e"
        "\xef\xff\xe1\x03\x4c\x3a\x3f\x94\x0a\x80\x5d\x0e\xbc\xf2\x6a\x43\x8c"
        "\x15\xed\xed\x8b\x92\xf0\x15\xa3\xbe\xe0\xb2\xd3\x1f\x7b\x27\x9b\xa5"
        "\xf4\x3a\xdc\x1b\x26\x3b\xbe\x3d\x6e\x20\x05\xaa\xb1\x36\x60\xc1\xcf"
        "\x29\xec\x14\xe2\xda\x54\xaf\x46\xd1\x32\xcc\x16\xd9\x84\xd3\x86\x10"
        "\x34\x7b\xcc\x58\x08\xf5\xf6\x7a\x47\xc2\x86\xc5\x7a\x6f\xad\x56\x98"
        "\x84\x6d\x09\x7a\x15\x8a\xfd\xa3\x4d\x1b\xc5\xff\x7d\x8b\x62\x91\xe4"
        "\x28\xec\x3a\xf5\xb5\x85\x3c\x5a\xda\xf0\xf5\x1d\xa9\x2a\x0f\xd0\x51"
        "\x9d\x9c\x9f\x14\xab\x78\x42\xfa\xc8\x1a\xdc\x72\xbc\x90\x6a\x14\xde"
        "\xe8\x82\xff\xe6\xa3\xd0\xf6\x83\x3b\xe7\x43\x24",
        3361));
    NONFAILING(sprintf((char*)0x20001d21, "%023llo", (long long)r[0]));
    NONFAILING(*(uint16_t*)0x20001d38 = r[2]);
    NONFAILING(*(uint64_t*)0x20001d3a = r[3]);
    NONFAILING(*(uint32_t*)0x20001d42 = -1);
    syz_usb_ep_write(r[1], 0x82, 0xd08, 0x20001000);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  install_segv_handler();
  for (procid = 0; procid < 6; procid++) {
    if (fork() == 0) {
      loop();
    }
  }
  sleep(1000000);
  return 0;
}
