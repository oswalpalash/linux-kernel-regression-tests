// https://syzkaller.appspot.com/bug?id=629ab2f4e0615bfbe6f924e42c6608e2383c083a
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>
#include <linux/usb/ch9.h>

static unsigned long long procid;

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i = 0;
  for (; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG, 1000000);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

#define MAX_FDS 30

#define USB_MAX_IFACE_NUM 4
#define USB_MAX_EP_NUM 32
#define USB_MAX_FDS 6

struct usb_endpoint_index {
  struct usb_endpoint_descriptor desc;
  int handle;
};

struct usb_iface_index {
  struct usb_interface_descriptor* iface;
  uint8_t bInterfaceNumber;
  uint8_t bAlternateSetting;
  uint8_t bInterfaceClass;
  struct usb_endpoint_index eps[USB_MAX_EP_NUM];
  int eps_num;
};

struct usb_device_index {
  struct usb_device_descriptor* dev;
  struct usb_config_descriptor* config;
  uint8_t bDeviceClass;
  uint8_t bMaxPower;
  int config_length;
  struct usb_iface_index ifaces[USB_MAX_IFACE_NUM];
  int ifaces_num;
  int iface_cur;
};

struct usb_info {
  int fd;
  struct usb_device_index index;
};

static struct usb_info usb_devices[USB_MAX_FDS];
static int usb_devices_num;

static bool parse_usb_descriptor(const char* buffer, size_t length,
                                 struct usb_device_index* index)
{
  if (length < sizeof(*index->dev) + sizeof(*index->config))
    return false;
  memset(index, 0, sizeof(*index));
  index->dev = (struct usb_device_descriptor*)buffer;
  index->config = (struct usb_config_descriptor*)(buffer + sizeof(*index->dev));
  index->bDeviceClass = index->dev->bDeviceClass;
  index->bMaxPower = index->config->bMaxPower;
  index->config_length = length - sizeof(*index->dev);
  index->iface_cur = -1;
  size_t offset = 0;
  while (true) {
    if (offset + 1 >= length)
      break;
    uint8_t desc_length = buffer[offset];
    uint8_t desc_type = buffer[offset + 1];
    if (desc_length <= 2)
      break;
    if (offset + desc_length > length)
      break;
    if (desc_type == USB_DT_INTERFACE &&
        index->ifaces_num < USB_MAX_IFACE_NUM) {
      struct usb_interface_descriptor* iface =
          (struct usb_interface_descriptor*)(buffer + offset);
      index->ifaces[index->ifaces_num].iface = iface;
      index->ifaces[index->ifaces_num].bInterfaceNumber =
          iface->bInterfaceNumber;
      index->ifaces[index->ifaces_num].bAlternateSetting =
          iface->bAlternateSetting;
      index->ifaces[index->ifaces_num].bInterfaceClass = iface->bInterfaceClass;
      index->ifaces_num++;
    }
    if (desc_type == USB_DT_ENDPOINT && index->ifaces_num > 0) {
      struct usb_iface_index* iface = &index->ifaces[index->ifaces_num - 1];
      if (iface->eps_num < USB_MAX_EP_NUM) {
        memcpy(&iface->eps[iface->eps_num].desc, buffer + offset,
               sizeof(iface->eps[iface->eps_num].desc));
        iface->eps_num++;
      }
    }
    offset += desc_length;
  }
  return true;
}

static struct usb_device_index* add_usb_index(int fd, const char* dev,
                                              size_t dev_len)
{
  int i = __atomic_fetch_add(&usb_devices_num, 1, __ATOMIC_RELAXED);
  if (i >= USB_MAX_FDS)
    return NULL;
  if (!parse_usb_descriptor(dev, dev_len, &usb_devices[i].index))
    return NULL;
  __atomic_store_n(&usb_devices[i].fd, fd, __ATOMIC_RELEASE);
  return &usb_devices[i].index;
}

static struct usb_device_index* lookup_usb_index(int fd)
{
  for (int i = 0; i < USB_MAX_FDS; i++) {
    if (__atomic_load_n(&usb_devices[i].fd, __ATOMIC_ACQUIRE) == fd) {
      return &usb_devices[i].index;
    }
  }
  return NULL;
}

struct vusb_connect_string_descriptor {
  uint32_t len;
  char* str;
} __attribute__((packed));

struct vusb_connect_descriptors {
  uint32_t qual_len;
  char* qual;
  uint32_t bos_len;
  char* bos;
  uint32_t strs_len;
  struct vusb_connect_string_descriptor strs[0];
} __attribute__((packed));

static const char default_string[] = {8, USB_DT_STRING, 's', 0, 'y', 0, 'z', 0};

static const char default_lang_id[] = {4, USB_DT_STRING, 0x09, 0x04};

static bool
lookup_connect_response_in(int fd, const struct vusb_connect_descriptors* descs,
                           const struct usb_ctrlrequest* ctrl,
                           char** response_data, uint32_t* response_length)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  uint8_t str_idx;
  if (!index)
    return false;
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_GET_DESCRIPTOR:
      switch (ctrl->wValue >> 8) {
      case USB_DT_DEVICE:
        *response_data = (char*)index->dev;
        *response_length = sizeof(*index->dev);
        return true;
      case USB_DT_CONFIG:
        *response_data = (char*)index->config;
        *response_length = index->config_length;
        return true;
      case USB_DT_STRING:
        str_idx = (uint8_t)ctrl->wValue;
        if (descs && str_idx < descs->strs_len) {
          *response_data = descs->strs[str_idx].str;
          *response_length = descs->strs[str_idx].len;
          return true;
        }
        if (str_idx == 0) {
          *response_data = (char*)&default_lang_id[0];
          *response_length = default_lang_id[0];
          return true;
        }
        *response_data = (char*)&default_string[0];
        *response_length = default_string[0];
        return true;
      case USB_DT_BOS:
        *response_data = descs->bos;
        *response_length = descs->bos_len;
        return true;
      case USB_DT_DEVICE_QUALIFIER:
        if (!descs->qual) {
          struct usb_qualifier_descriptor* qual =
              (struct usb_qualifier_descriptor*)response_data;
          qual->bLength = sizeof(*qual);
          qual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;
          qual->bcdUSB = index->dev->bcdUSB;
          qual->bDeviceClass = index->dev->bDeviceClass;
          qual->bDeviceSubClass = index->dev->bDeviceSubClass;
          qual->bDeviceProtocol = index->dev->bDeviceProtocol;
          qual->bMaxPacketSize0 = index->dev->bMaxPacketSize0;
          qual->bNumConfigurations = index->dev->bNumConfigurations;
          qual->bRESERVED = 0;
          *response_length = sizeof(*qual);
          return true;
        }
        *response_data = descs->qual;
        *response_length = descs->qual_len;
        return true;
      default:
        break;
      }
      break;
    default:
      break;
    }
    break;
  default:
    break;
  }
  return false;
}

typedef bool (*lookup_connect_out_response_t)(
    int fd, const struct vusb_connect_descriptors* descs,
    const struct usb_ctrlrequest* ctrl, bool* done);

static bool lookup_connect_response_out_generic(
    int fd, const struct vusb_connect_descriptors* descs,
    const struct usb_ctrlrequest* ctrl, bool* done)
{
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_SET_CONFIGURATION:
      *done = true;
      return true;
    default:
      break;
    }
    break;
  }
  return false;
}

struct vusb_descriptor {
  uint8_t req_type;
  uint8_t desc_type;
  uint32_t len;
  char data[0];
} __attribute__((packed));

struct vusb_descriptors {
  uint32_t len;
  struct vusb_descriptor* generic;
  struct vusb_descriptor* descs[0];
} __attribute__((packed));

struct vusb_response {
  uint8_t type;
  uint8_t req;
  uint32_t len;
  char data[0];
} __attribute__((packed));

struct vusb_responses {
  uint32_t len;
  struct vusb_response* generic;
  struct vusb_response* resps[0];
} __attribute__((packed));

static bool lookup_control_response(const struct vusb_descriptors* descs,
                                    const struct vusb_responses* resps,
                                    struct usb_ctrlrequest* ctrl,
                                    char** response_data,
                                    uint32_t* response_length)
{
  int descs_num = 0;
  int resps_num = 0;
  if (descs)
    descs_num = (descs->len - offsetof(struct vusb_descriptors, descs)) /
                sizeof(descs->descs[0]);
  if (resps)
    resps_num = (resps->len - offsetof(struct vusb_responses, resps)) /
                sizeof(resps->resps[0]);
  uint8_t req = ctrl->bRequest;
  uint8_t req_type = ctrl->bRequestType & USB_TYPE_MASK;
  uint8_t desc_type = ctrl->wValue >> 8;
  if (req == USB_REQ_GET_DESCRIPTOR) {
    int i;
    for (i = 0; i < descs_num; i++) {
      struct vusb_descriptor* desc = descs->descs[i];
      if (!desc)
        continue;
      if (desc->req_type == req_type && desc->desc_type == desc_type) {
        *response_length = desc->len;
        if (*response_length != 0)
          *response_data = &desc->data[0];
        else
          *response_data = NULL;
        return true;
      }
    }
    if (descs && descs->generic) {
      *response_data = &descs->generic->data[0];
      *response_length = descs->generic->len;
      return true;
    }
  } else {
    int i;
    for (i = 0; i < resps_num; i++) {
      struct vusb_response* resp = resps->resps[i];
      if (!resp)
        continue;
      if (resp->type == req_type && resp->req == req) {
        *response_length = resp->len;
        if (*response_length != 0)
          *response_data = &resp->data[0];
        else
          *response_data = NULL;
        return true;
      }
    }
    if (resps && resps->generic) {
      *response_data = &resps->generic->data[0];
      *response_length = resps->generic->len;
      return true;
    }
  }
  return false;
}

#define UDC_NAME_LENGTH_MAX 128

struct usb_raw_init {
  __u8 driver_name[UDC_NAME_LENGTH_MAX];
  __u8 device_name[UDC_NAME_LENGTH_MAX];
  __u8 speed;
};

enum usb_raw_event_type {
  USB_RAW_EVENT_INVALID = 0,
  USB_RAW_EVENT_CONNECT = 1,
  USB_RAW_EVENT_CONTROL = 2,
};

struct usb_raw_event {
  __u32 type;
  __u32 length;
  __u8 data[0];
};

struct usb_raw_ep_io {
  __u16 ep;
  __u16 flags;
  __u32 length;
  __u8 data[0];
};

#define USB_RAW_EPS_NUM_MAX 30
#define USB_RAW_EP_NAME_MAX 16
#define USB_RAW_EP_ADDR_ANY 0xff

struct usb_raw_ep_caps {
  __u32 type_control : 1;
  __u32 type_iso : 1;
  __u32 type_bulk : 1;
  __u32 type_int : 1;
  __u32 dir_in : 1;
  __u32 dir_out : 1;
};

struct usb_raw_ep_limits {
  __u16 maxpacket_limit;
  __u16 max_streams;
  __u32 reserved;
};

struct usb_raw_ep_info {
  __u8 name[USB_RAW_EP_NAME_MAX];
  __u32 addr;
  struct usb_raw_ep_caps caps;
  struct usb_raw_ep_limits limits;
};

struct usb_raw_eps_info {
  struct usb_raw_ep_info eps[USB_RAW_EPS_NUM_MAX];
};

#define USB_RAW_IOCTL_INIT _IOW('U', 0, struct usb_raw_init)
#define USB_RAW_IOCTL_RUN _IO('U', 1)
#define USB_RAW_IOCTL_EVENT_FETCH _IOR('U', 2, struct usb_raw_event)
#define USB_RAW_IOCTL_EP0_WRITE _IOW('U', 3, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP0_READ _IOWR('U', 4, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_ENABLE _IOW('U', 5, struct usb_endpoint_descriptor)
#define USB_RAW_IOCTL_EP_DISABLE _IOW('U', 6, __u32)
#define USB_RAW_IOCTL_EP_WRITE _IOW('U', 7, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_READ _IOWR('U', 8, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_CONFIGURE _IO('U', 9)
#define USB_RAW_IOCTL_VBUS_DRAW _IOW('U', 10, __u32)
#define USB_RAW_IOCTL_EPS_INFO _IOR('U', 11, struct usb_raw_eps_info)
#define USB_RAW_IOCTL_EP0_STALL _IO('U', 12)
#define USB_RAW_IOCTL_EP_SET_HALT _IOW('U', 13, __u32)
#define USB_RAW_IOCTL_EP_CLEAR_HALT _IOW('U', 14, __u32)
#define USB_RAW_IOCTL_EP_SET_WEDGE _IOW('U', 15, __u32)

static int usb_raw_open()
{
  return open("/dev/raw-gadget", O_RDWR);
}

static int usb_raw_init(int fd, uint32_t speed, const char* driver,
                        const char* device)
{
  struct usb_raw_init arg;
  strncpy((char*)&arg.driver_name[0], driver, sizeof(arg.driver_name));
  strncpy((char*)&arg.device_name[0], device, sizeof(arg.device_name));
  arg.speed = speed;
  return ioctl(fd, USB_RAW_IOCTL_INIT, &arg);
}

static int usb_raw_run(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_RUN, 0);
}

static int usb_raw_event_fetch(int fd, struct usb_raw_event* event)
{
  return ioctl(fd, USB_RAW_IOCTL_EVENT_FETCH, event);
}

static int usb_raw_ep0_write(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_WRITE, io);
}

static int usb_raw_ep0_read(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_READ, io);
}

static int usb_raw_ep_enable(int fd, struct usb_endpoint_descriptor* desc)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_ENABLE, desc);
}

static int usb_raw_ep_disable(int fd, int ep)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_DISABLE, ep);
}

static int usb_raw_configure(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_CONFIGURE, 0);
}

static int usb_raw_vbus_draw(int fd, uint32_t power)
{
  return ioctl(fd, USB_RAW_IOCTL_VBUS_DRAW, power);
}

static int usb_raw_ep0_stall(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_STALL, 0);
}

static int lookup_interface(int fd, uint8_t bInterfaceNumber,
                            uint8_t bAlternateSetting)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return -1;
  for (int i = 0; i < index->ifaces_num; i++) {
    if (index->ifaces[i].bInterfaceNumber == bInterfaceNumber &&
        index->ifaces[i].bAlternateSetting == bAlternateSetting)
      return i;
  }
  return -1;
}

static void set_interface(int fd, int n)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return;
  if (index->iface_cur >= 0 && index->iface_cur < index->ifaces_num) {
    for (int ep = 0; ep < index->ifaces[index->iface_cur].eps_num; ep++) {
      int rv = usb_raw_ep_disable(
          fd, index->ifaces[index->iface_cur].eps[ep].handle);
      if (rv < 0) {
      } else {
      }
    }
  }
  if (n >= 0 && n < index->ifaces_num) {
    for (int ep = 0; ep < index->ifaces[n].eps_num; ep++) {
      int rv = usb_raw_ep_enable(fd, &index->ifaces[n].eps[ep].desc);
      if (rv < 0) {
      } else {
        index->ifaces[n].eps[ep].handle = rv;
      }
    }
    index->iface_cur = n;
  }
}

static int configure_device(int fd)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return -1;
  int rv = usb_raw_vbus_draw(fd, index->bMaxPower);
  if (rv < 0) {
    return rv;
  }
  rv = usb_raw_configure(fd);
  if (rv < 0) {
    return rv;
  }
  set_interface(fd, 0);
  return 0;
}

#define USB_MAX_PACKET_SIZE 4096

struct usb_raw_control_event {
  struct usb_raw_event inner;
  struct usb_ctrlrequest ctrl;
  char data[USB_MAX_PACKET_SIZE];
};

struct usb_raw_ep_io_data {
  struct usb_raw_ep_io inner;
  char data[USB_MAX_PACKET_SIZE];
};

static volatile long
syz_usb_connect_impl(uint64_t speed, uint64_t dev_len, const char* dev,
                     const struct vusb_connect_descriptors* descs,
                     lookup_connect_out_response_t lookup_connect_response_out)
{
  if (!dev) {
    return -1;
  }
  int fd = usb_raw_open();
  if (fd < 0) {
    return fd;
  }
  if (fd >= MAX_FDS) {
    close(fd);
    return -1;
  }
  struct usb_device_index* index = add_usb_index(fd, dev, dev_len);
  if (!index) {
    return -1;
  }
  char device[32];
  sprintf(&device[0], "dummy_udc.%llu", procid);
  int rv = usb_raw_init(fd, speed, "dummy_udc", &device[0]);
  if (rv < 0) {
    return rv;
  }
  rv = usb_raw_run(fd);
  if (rv < 0) {
    return rv;
  }
  bool done = false;
  while (!done) {
    struct usb_raw_control_event event;
    event.inner.type = 0;
    event.inner.length = sizeof(event.ctrl);
    rv = usb_raw_event_fetch(fd, (struct usb_raw_event*)&event);
    if (rv < 0) {
      return rv;
    }
    if (event.inner.type != USB_RAW_EVENT_CONTROL)
      continue;
    char* response_data = NULL;
    uint32_t response_length = 0;
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      if (!lookup_connect_response_in(fd, descs, &event.ctrl, &response_data,
                                      &response_length)) {
        usb_raw_ep0_stall(fd);
        continue;
      }
    } else {
      if (!lookup_connect_response_out(fd, descs, &event.ctrl, &done)) {
        usb_raw_ep0_stall(fd);
        continue;
      }
      response_data = NULL;
      response_length = event.ctrl.wLength;
    }
    if ((event.ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD &&
        event.ctrl.bRequest == USB_REQ_SET_CONFIGURATION) {
      rv = configure_device(fd);
      if (rv < 0) {
        return rv;
      }
    }
    struct usb_raw_ep_io_data response;
    response.inner.ep = 0;
    response.inner.flags = 0;
    if (response_length > sizeof(response.data))
      response_length = 0;
    if (event.ctrl.wLength < response_length)
      response_length = event.ctrl.wLength;
    response.inner.length = response_length;
    if (response_data)
      memcpy(&response.data[0], response_data, response_length);
    else
      memset(&response.data[0], 0, response_length);
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      rv = usb_raw_ep0_write(fd, (struct usb_raw_ep_io*)&response);
    } else {
      rv = usb_raw_ep0_read(fd, (struct usb_raw_ep_io*)&response);
    }
    if (rv < 0) {
      return rv;
    }
  }
  sleep_ms(200);
  return fd;
}

static volatile long syz_usb_connect(volatile long a0, volatile long a1,
                                     volatile long a2, volatile long a3)
{
  uint64_t speed = a0;
  uint64_t dev_len = a1;
  const char* dev = (const char*)a2;
  const struct vusb_connect_descriptors* descs =
      (const struct vusb_connect_descriptors*)a3;
  return syz_usb_connect_impl(speed, dev_len, dev, descs,
                              &lookup_connect_response_out_generic);
}

static volatile long syz_usb_control_io(volatile long a0, volatile long a1,
                                        volatile long a2)
{
  int fd = a0;
  const struct vusb_descriptors* descs = (const struct vusb_descriptors*)a1;
  const struct vusb_responses* resps = (const struct vusb_responses*)a2;
  struct usb_raw_control_event event;
  event.inner.type = 0;
  event.inner.length = USB_MAX_PACKET_SIZE;
  int rv = usb_raw_event_fetch(fd, (struct usb_raw_event*)&event);
  if (rv < 0) {
    return rv;
  }
  if (event.inner.type != USB_RAW_EVENT_CONTROL) {
    return -1;
  }
  char* response_data = NULL;
  uint32_t response_length = 0;
  if ((event.ctrl.bRequestType & USB_DIR_IN) && event.ctrl.wLength) {
    if (!lookup_control_response(descs, resps, &event.ctrl, &response_data,
                                 &response_length)) {
      usb_raw_ep0_stall(fd);
      return -1;
    }
  } else {
    if ((event.ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD ||
        event.ctrl.bRequest == USB_REQ_SET_INTERFACE) {
      int iface_num = event.ctrl.wIndex;
      int alt_set = event.ctrl.wValue;
      int iface_index = lookup_interface(fd, iface_num, alt_set);
      if (iface_index < 0) {
      } else {
        set_interface(fd, iface_index);
      }
    }
    response_length = event.ctrl.wLength;
  }
  struct usb_raw_ep_io_data response;
  response.inner.ep = 0;
  response.inner.flags = 0;
  if (response_length > sizeof(response.data))
    response_length = 0;
  if (event.ctrl.wLength < response_length)
    response_length = event.ctrl.wLength;
  if ((event.ctrl.bRequestType & USB_DIR_IN) && !event.ctrl.wLength) {
    response_length = USB_MAX_PACKET_SIZE;
  }
  response.inner.length = response_length;
  if (response_data)
    memcpy(&response.data[0], response_data, response_length);
  else
    memset(&response.data[0], 0, response_length);
  if ((event.ctrl.bRequestType & USB_DIR_IN) && event.ctrl.wLength) {
    rv = usb_raw_ep0_write(fd, (struct usb_raw_ep_io*)&response);
  } else {
    rv = usb_raw_ep0_read(fd, (struct usb_raw_ep_io*)&response);
  }
  if (rv < 0) {
    return rv;
  }
  sleep_ms(200);
  return 0;
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  for (int i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  int i, call, thread;
  int collide = 0;
again:
  for (call = 0; call < 4; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      if (collide && (call % 2) == 0)
        break;
      event_timedwait(&th->done, 50 + (call == 0 ? 3000 : 0) +
                                     (call == 1 ? 300 : 0) +
                                     (call == 2 ? 3000 : 0));
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
  if (!collide) {
    collide = 1;
    goto again;
  }
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter = 0;
  for (;; iter++) {
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5000) {
        continue;
      }
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[1] = {0xffffffffffffffff};

void execute_call(int call)
{
  intptr_t res = 0;
  switch (call) {
  case 0:
    memcpy((void*)0x20000000,
           "\x11\x01\x00\x00\x73\x33\x36\x08\x8d\xee\x1a\xdb\x23\x61\x00\x00"
           "\x00\x01\x09\x02\x2d\x00\x01\x00\x00\x00\x00\x09\x04\x00\x00\x03"
           "\xfe\x03\x01\x00\x09\x05\x8d\x1f\x00\x02\x00\x00\x00\x09\x05\x05"
           "\x02\x00\xde\x7e\x00\x00\x09\x05\x8b\x1e\x20",
           59);
    res = -1;
    res = syz_usb_connect(0, 0x3f, 0x20000000, 0);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    *(uint32_t*)0x20000400 = 0x44;
    *(uint64_t*)0x20000404 = 0x20000480;
    *(uint64_t*)0x2000040c = 0;
    *(uint64_t*)0x20000414 = 0;
    *(uint64_t*)0x2000041c = 0;
    *(uint64_t*)0x20000424 = 0;
    *(uint64_t*)0x2000042c = 0;
    *(uint64_t*)0x20000434 = 0;
    *(uint64_t*)0x2000043c = 0;
    syz_usb_control_io(r[0], 0, 0x20000400);
    break;
  case 2:
    *(uint8_t*)0x20000040 = 0x12;
    *(uint8_t*)0x20000041 = 1;
    *(uint16_t*)0x20000042 = 0x110;
    *(uint8_t*)0x20000044 = 0;
    *(uint8_t*)0x20000045 = 0;
    *(uint8_t*)0x20000046 = 0;
    *(uint8_t*)0x20000047 = 0x20;
    *(uint16_t*)0x20000048 = 0x1d6b;
    *(uint16_t*)0x2000004a = 0x101;
    *(uint16_t*)0x2000004c = 0x40;
    *(uint8_t*)0x2000004e = 1;
    *(uint8_t*)0x2000004f = 2;
    *(uint8_t*)0x20000050 = 3;
    *(uint8_t*)0x20000051 = 1;
    *(uint8_t*)0x20000052 = 9;
    *(uint8_t*)0x20000053 = 2;
    *(uint16_t*)0x20000054 = 0xb9;
    *(uint8_t*)0x20000056 = 3;
    *(uint8_t*)0x20000057 = 1;
    *(uint8_t*)0x20000058 = 0;
    *(uint8_t*)0x20000059 = 0x30;
    *(uint8_t*)0x2000005a = -1;
    *(uint8_t*)0x2000005b = 9;
    *(uint8_t*)0x2000005c = 4;
    *(uint8_t*)0x2000005d = 0;
    *(uint8_t*)0x2000005e = 0;
    *(uint8_t*)0x2000005f = 0;
    *(uint8_t*)0x20000060 = 1;
    *(uint8_t*)0x20000061 = 1;
    *(uint8_t*)0x20000062 = 0;
    *(uint8_t*)0x20000063 = 0;
    *(uint8_t*)0x20000064 = 0xa;
    *(uint8_t*)0x20000065 = 0x24;
    *(uint8_t*)0x20000066 = 1;
    *(uint16_t*)0x20000067 = 0xfff;
    *(uint8_t*)0x20000069 = 7;
    *(uint8_t*)0x2000006a = 2;
    *(uint8_t*)0x2000006b = 1;
    *(uint8_t*)0x2000006c = 2;
    *(uint8_t*)0x2000006d = 0xa;
    *(uint8_t*)0x2000006e = 0x24;
    *(uint8_t*)0x2000006f = 7;
    *(uint8_t*)0x20000070 = 6;
    *(uint16_t*)0x20000071 = 3;
    *(uint8_t*)0x20000073 = 4;
    memcpy((void*)0x20000074, "\xb3\xe0\x0b", 3);
    *(uint8_t*)0x20000077 = 0xb;
    *(uint8_t*)0x20000078 = 0x24;
    *(uint8_t*)0x20000079 = 7;
    *(uint8_t*)0x2000007a = 3;
    *(uint16_t*)0x2000007b = 3;
    *(uint8_t*)0x2000007d = 4;
    memcpy((void*)0x2000007e, "\x7e\xd0\x10\x0d", 4);
    *(uint8_t*)0x20000082 = 9;
    *(uint8_t*)0x20000083 = 4;
    *(uint8_t*)0x20000084 = 1;
    *(uint8_t*)0x20000085 = 0;
    *(uint8_t*)0x20000086 = 0;
    *(uint8_t*)0x20000087 = 1;
    *(uint8_t*)0x20000088 = 2;
    *(uint8_t*)0x20000089 = 0;
    *(uint8_t*)0x2000008a = 0;
    *(uint8_t*)0x2000008b = 9;
    *(uint8_t*)0x2000008c = 4;
    *(uint8_t*)0x2000008d = 1;
    *(uint8_t*)0x2000008e = 1;
    *(uint8_t*)0x2000008f = 1;
    *(uint8_t*)0x20000090 = 1;
    *(uint8_t*)0x20000091 = 2;
    *(uint8_t*)0x20000092 = 0;
    *(uint8_t*)0x20000093 = 0;
    *(uint8_t*)0x20000094 = 0xb;
    *(uint8_t*)0x20000095 = 0x24;
    *(uint8_t*)0x20000096 = 2;
    *(uint8_t*)0x20000097 = 1;
    *(uint8_t*)0x20000098 = 7;
    *(uint8_t*)0x20000099 = 3;
    *(uint8_t*)0x2000009a = 0x80;
    *(uint8_t*)0x2000009b = 1;
    memcpy((void*)0x2000009c, "\x22\x74\x16", 3);
    *(uint8_t*)0x2000009f = 9;
    *(uint8_t*)0x200000a0 = 5;
    *(uint8_t*)0x200000a1 = 1;
    *(uint8_t*)0x200000a2 = 9;
    *(uint16_t*)0x200000a3 = 0x20;
    *(uint8_t*)0x200000a5 = 0x80;
    *(uint8_t*)0x200000a6 = 7;
    *(uint8_t*)0x200000a7 = 0xc9;
    *(uint8_t*)0x200000a8 = 7;
    *(uint8_t*)0x200000a9 = 0x25;
    *(uint8_t*)0x200000aa = 1;
    *(uint8_t*)0x200000ab = 0x82;
    *(uint8_t*)0x200000ac = 0x80;
    *(uint16_t*)0x200000ad = 0x80;
    *(uint8_t*)0x200000af = 9;
    *(uint8_t*)0x200000b0 = 4;
    *(uint8_t*)0x200000b1 = 2;
    *(uint8_t*)0x200000b2 = 0;
    *(uint8_t*)0x200000b3 = 0;
    *(uint8_t*)0x200000b4 = 1;
    *(uint8_t*)0x200000b5 = 2;
    *(uint8_t*)0x200000b6 = 0;
    *(uint8_t*)0x200000b7 = 0;
    *(uint8_t*)0x200000b8 = 9;
    *(uint8_t*)0x200000b9 = 4;
    *(uint8_t*)0x200000ba = 2;
    *(uint8_t*)0x200000bb = 1;
    *(uint8_t*)0x200000bc = 1;
    *(uint8_t*)0x200000bd = 1;
    *(uint8_t*)0x200000be = 2;
    *(uint8_t*)0x200000bf = 0;
    *(uint8_t*)0x200000c0 = 0;
    *(uint8_t*)0x200000c1 = 7;
    *(uint8_t*)0x200000c2 = 0x24;
    *(uint8_t*)0x200000c3 = 1;
    *(uint8_t*)0x200000c4 = 0xb1;
    *(uint8_t*)0x200000c5 = 0xfc;
    *(uint16_t*)0x200000c6 = 0x1001;
    *(uint8_t*)0x200000c8 = 8;
    *(uint8_t*)0x200000c9 = 0x24;
    *(uint8_t*)0x200000ca = 2;
    *(uint8_t*)0x200000cb = 1;
    *(uint8_t*)0x200000cc = 0;
    *(uint8_t*)0x200000cd = 1;
    *(uint8_t*)0x200000ce = 2;
    *(uint8_t*)0x200000cf = 2;
    *(uint8_t*)0x200000d0 = 9;
    *(uint8_t*)0x200000d1 = 0x24;
    *(uint8_t*)0x200000d2 = 2;
    *(uint8_t*)0x200000d3 = 1;
    *(uint8_t*)0x200000d4 = 0x20;
    *(uint8_t*)0x200000d5 = 1;
    *(uint8_t*)0x200000d6 = 0x40;
    *(uint8_t*)0x200000d7 = 0x3f;
    memset((void*)0x200000d8, 33, 1);
    *(uint8_t*)0x200000d9 = 0xd;
    *(uint8_t*)0x200000da = 0x24;
    *(uint8_t*)0x200000db = 2;
    *(uint8_t*)0x200000dc = 1;
    *(uint8_t*)0x200000dd = 1;
    *(uint8_t*)0x200000de = 1;
    *(uint8_t*)0x200000df = 3;
    *(uint8_t*)0x200000e0 = 0x23;
    memcpy((void*)0x200000e1, "\xdb\x17\xe1\xaa\xdc", 5);
    *(uint8_t*)0x200000e6 = 0xa;
    *(uint8_t*)0x200000e7 = 0x24;
    *(uint8_t*)0x200000e8 = 2;
    *(uint8_t*)0x200000e9 = 1;
    *(uint8_t*)0x200000ea = 5;
    *(uint8_t*)0x200000eb = 4;
    *(uint8_t*)0x200000ec = 0x16;
    *(uint8_t*)0x200000ed = -1;
    memcpy((void*)0x200000ee, "\x74\xb8", 2);
    *(uint8_t*)0x200000f0 = 0xb;
    *(uint8_t*)0x200000f1 = 0x24;
    *(uint8_t*)0x200000f2 = 2;
    *(uint8_t*)0x200000f3 = 1;
    *(uint8_t*)0x200000f4 = 7;
    *(uint8_t*)0x200000f5 = 3;
    *(uint8_t*)0x200000f6 = 0x20;
    *(uint8_t*)0x200000f7 = 3;
    memcpy((void*)0x200000f8, "\x00\x47\xe4", 3);
    *(uint8_t*)0x200000fb = 9;
    *(uint8_t*)0x200000fc = 5;
    *(uint8_t*)0x200000fd = 0x82;
    *(uint8_t*)0x200000fe = 9;
    *(uint16_t*)0x200000ff = 0x400;
    *(uint8_t*)0x20000101 = 7;
    *(uint8_t*)0x20000102 = 9;
    *(uint8_t*)0x20000103 = 2;
    *(uint8_t*)0x20000104 = 7;
    *(uint8_t*)0x20000105 = 0x25;
    *(uint8_t*)0x20000106 = 1;
    *(uint8_t*)0x20000107 = 2;
    *(uint8_t*)0x20000108 = 5;
    *(uint16_t*)0x20000109 = 2;
    *(uint32_t*)0x20000280 = 0xa;
    *(uint64_t*)0x20000284 = 0x20000140;
    *(uint8_t*)0x20000140 = 0xa;
    *(uint8_t*)0x20000141 = 6;
    *(uint16_t*)0x20000142 = 0x200;
    *(uint8_t*)0x20000144 = 7;
    *(uint8_t*)0x20000145 = 9;
    *(uint8_t*)0x20000146 = 0;
    *(uint8_t*)0x20000147 = 0x20;
    *(uint8_t*)0x20000148 = 7;
    *(uint8_t*)0x20000149 = 0;
    *(uint32_t*)0x2000028c = 5;
    *(uint64_t*)0x20000290 = 0x20000180;
    *(uint8_t*)0x20000180 = 5;
    *(uint8_t*)0x20000181 = 0xf;
    *(uint16_t*)0x20000182 = 5;
    *(uint8_t*)0x20000184 = 0;
    *(uint32_t*)0x20000298 = 3;
    *(uint32_t*)0x2000029c = 4;
    *(uint64_t*)0x200002a0 = 0x200001c0;
    *(uint8_t*)0x200001c0 = 4;
    *(uint8_t*)0x200001c1 = 3;
    *(uint16_t*)0x200001c2 = 0x426;
    *(uint32_t*)0x200002a8 = 4;
    *(uint64_t*)0x200002ac = 0x20000200;
    *(uint8_t*)0x20000200 = 4;
    *(uint8_t*)0x20000201 = 3;
    *(uint16_t*)0x20000202 = 0x415;
    *(uint32_t*)0x200002b4 = 4;
    *(uint64_t*)0x200002b8 = 0x20000240;
    *(uint8_t*)0x20000240 = 4;
    *(uint8_t*)0x20000241 = 3;
    *(uint16_t*)0x20000242 = 0x812;
    syz_usb_connect(4, 0xcb, 0x20000040, 0x20000280);
    break;
  case 3:
    memcpy(
        (void*)0x20000b80,
        "\x41\xb6\x58\xa8\xe3\x1e\x91\xcd\x17\x27\x08\x37\xb0\x5b\x3f\x29\x8a"
        "\x37\x54\x1b\x7d\xb6\x9f\x1c\x16\xb8\xcc\x7e\x04\x6c\x08\x66\xc2\x4b"
        "\x22\x87\x58\x58\xdf\x50\x94\x63\x44\xd3\x25\xaf\x81\xcc\x53\x69\x5b"
        "\xaa\x38\x37\x63\x6d\x6a\xbc\x26\xd6\x8c\x80\xa2\xf7\x62\x53\x5b\x44"
        "\x32\xbc\xde\x42\xe1\x66\x94\xb6\x04\x14\x72\xf3\xef\xb7\x95\x5e\xc9"
        "\x3e\x53\x87\x3a\x96\x49\x77\x5d\x23\xe3\x30\xe5\xcb\x63\x7a\xa8\x2e"
        "\xac\x50\xcf\x4a\xaa\x1d\xc0\x08\x5a\xf1\xcd\xd4\xdb\xe6\x37\xa5\xbe"
        "\x54\x06\x22\xbd\x7f\xa4\xf8\xea\x22\xee\x82\xdc\xd1\x71\xc7\xb5\xeb"
        "\xe1\xf4\x48\x41\xd4\x0a\xf1\x85\xaa\xf2\xfb\x70\x62\x84\x6f\x7f\x94"
        "\xc4\x38\x33\xa2\x8d\x06\xad\x8c\x0e\xf7\x38\x05\x92\xd8\x13\x4a\xed"
        "\xb3\x1a\xe5\x67\x33\x77\x94\x03\x15\x2d\xad\x5b\x5b\x2c\x9b\x15\x2a"
        "\x82\x07\x9c\x2b\x3b\xa3\x0b\x67\xdf\xe5\x2b\x3d\x25\xa5\xa3\x51\x0d"
        "\x43\x70\xb9\x5f\x45\x5b\x31\x62\x9a\xc7\xc0\xe6\x67\x1a\x0a\xbc\x12"
        "\x1f\x07\x7d\xd3\xde\x77\xcd\x80\xd7\x59\x91\x7a\xd2\xce\x24\x34\xbe"
        "\xd7\x12\xc7\xa4\x99\x82\x3f\xcf\xfb\xcb\xc7\xfe\x6a\x6e\x40\x37\xe7"
        "\xda\x33\x83\x0a\x5a\x9d\x47\xad\x12\x06\x4e\x0e\x1e\x8b\x90\x38\xe7"
        "\x6d\x7c\x45\x57\xa7\xff\x3a\xa3\x69\xcd\xc5\xbc\x8e\x6c\x8e\x91\x8c"
        "\x99\xb3\x7a\x1a\x61\xa8\x54\xa2\x6c\xc2\x21\xeb\x7b\x8c\x20\x1c\x3c"
        "\x7e\x8b\xca\xca\x14\x14\x41\x0d\x70\x58\x32\xe4\x46\x25\xc0\x13\xea"
        "\x69\xd9\x9a\x1b\x46\x65\xa1\xc2\x25\xe2\x6c\xb1\xb0\x44\x9e\xf7\x57"
        "\x53\x2d\x43\xc1\x4c\x86\xe0\xcd\x33\x61\xbd\xca\xa3\x53\xc8\x73\x17"
        "\xde\x54\xc1\x72\x05\xe7\x75\xb1\x6d\x49\x30\xf7\x14\x8c\xbe\xc1\x2e"
        "\x06\xa6\x7f\x5b\xb7\x0f\xb6\xb6\xa5\x11\xe4\x73\x9d\x28\x95\xa3\xff"
        "\x72\x40\x68\x64\xa7\x00\xea\x51\x39\x3d\x71\x89\x9a\xda\xf3\xfd\xd0"
        "\x8a\xc5\xc2\xf4\xde\xb5\x07\x82\x75\x5d\x1b\x21\x6c\x38\x86\x48\x38"
        "\x4c\xc2\xbb\x7d\x19\x98\xf8\x12\x16\x92\xab\x11\x9f\x75\x71\x09\x9f"
        "\xf0\x83\x59\xc2\xde\x1d\x9d\xf9\x07\x14\xc2\xac\x99\xb6\xa6\x9f\x70"
        "\xee\x60\xc5\x50\x99\x1b\x03\x34\x34\x98\x06\x97\x5c\x9f\x29\xe6\x68"
        "\x44\xba\x8d\xaf\x7f\x16\x74\xa5\x0b\x8f\x8a\xf9\xcd\x56\xf5\x49\xf9"
        "\x87\x9b\xc5\xe8\x22\x53\xf5\xb1\x04\x0c\x1a\x12\x6c\x1f\x21\xa4\x55"
        "\x48\x6b\xf0\x15\x43\xf7\x48\x09\x1e\xe9\x64\x45\x52\xa2\x3d\x2c\x15"
        "\xa7\x86\x12\xfa\x8b\xad\x1f\xcd\xf9\x85\x78\xb8\x88\x7d\xd5\x3f\x1b"
        "\x04\x8b\xd4\xbc\x68\xa4\x00\xc1\x34\x6b\x80\xe8\x21\x8a\xe2\x02\xb9"
        "\x73\xd1\xa7\xb8\x20\x1a\x46\x11\x29\x94\x8d\xa5\xf2\x37\x7c\x6f\xb8"
        "\x93\xbf\x98\xa1\xb9\xbc\x65\xe6\x4e\x87\x7d\x71\xda\x1c\xcd\x5a\xef"
        "\x7e\x33\xc0\xf7\x22\x67\xd6\xae\xe7\x6b\x88\x2b\xf3\x66\x9c\x46\xda"
        "\x76\xe5\xfb\x5a\xe9\x54\xbe\x90\x29\x73\x8b\x48\x01\xf7\x6e\x46\x2a"
        "\xb6\xfa\x6a\x79\x3f\x84\xec\xe1\xb9\xd4\x0c\x7c\x19\x9b\xe4\x17\xa1"
        "\x7e\x9b\x09\xc3\x2e\xdd\xbf\x38\x83\xf9\x7a\x3f\x1e\xd6\x60\xf8\x11"
        "\x6a\x2e\x66\x3e\xf1\x27\xa3\xe2\xb4\x8c\x99\xb6\xbc\x57\xb8\x36\xdf"
        "\x36\x1f\x7b\xc7\x08\x50\xa9\xf7\x3a\x0b\xbb\xe4\x5f\xbf\xbf\xc0\xde"
        "\x82\xc4\x20\xdf\x61\x49\x7e\xc3\x75\x90\x3b\xd9\xbe\xef\x45\xbb\xb3"
        "\xbc\xb1\x8c\xb4\xb4\xac\xf1\x79\xdf\x3e\xba\x80\x01\xa0\xd9\x63\x1f"
        "\x14\xe6\x4a\xe8\x3e\x1c\xf8\xd5\xa6\xfc\x4d\xf2\x79\x50\xe8\x6b\xba"
        "\x73\x36\x3f\x37\xa2\x7a\x86\xd7\x2a\x7b\x0e\x1f\xbe\x06\x89\x98\xd6"
        "\x00\x35\x28\xd4\xdf\x5b\x59\x88\x89\x18\x56\x08\xc5\x87\x04\x89\xd7"
        "\xcd\xdc\x6e\x05\x42\xf0\x52\xa4\x36\xba\xff\x8f\xc7\x59\x3f\x68\x67"
        "\xb8\xb3\xee\xf2\xdf\xb6\xeb\x45\x72\x9c\xd6\x86\xfb\xf8\x37\x34\x84"
        "\x77\x36\xee\x6f\x83\x29\x8b\x67\xdb\x3e\x27\x93\x08\x29\x08\xb6\xe0"
        "\x30\x40\x52\x7f\x12\xb2\x94\x19\xdf\x4d\xc8\x4c\x7d\x05\xff\x21\x08"
        "\x3a\xd3\x8f\x93\x6c\x81\xbb\xd0\x54\x8e\xbf\x64\x4b\x0d\xa0\xd8\xb4"
        "\x8d\xc5\xe0\xd3\xfe\x71\x76\xf4\x39\x77\xa4\x70\x99\x6f\xac\xf4\xee"
        "\xda\xb0\x88\x64\x28\xae\x10\x4c\xfd\xb7\x05\x18\xe1\xb5\x72\x89\xa7"
        "\xd2\x0b\x9d\xd6\x3c\x60\x6f\x67\x6e\xda\xf1\x48\xfb\xa4\x66\xaf\x2b"
        "\xb6\xc0\xa9\x7a\x1b\x61\xc1\x06\x5d\x43\x0d\x64\xa9\xf8\x70\x7c\x3f"
        "\x76\x0c\xf1\x8c\x20\x5e\xd9\x53\x26\x53\x84\xf0\x09\xe9\x9a\x7a\x82"
        "\x66\x17\xec\xaf\x28\xc6\x1a\x4d\x4b\x03\x7e\xd3\xc3\xb4\x80\x32\xc6"
        "\xc6\xf8\x76\x8d\x28\x91\x40\x92\x4f\x34\x52\x69\xe0\x64\x6f\xa1\x73"
        "\xc3\x73\x67\x31\xc6\x99\x20\x8f\xa1\x74\xe2\xb9\xf2\x41\x08\x3e\x0b"
        "\x1f\xff\x38\x84\x26\xb0\xa6\x93\xb0\x9a\xf9\x1d\x7d\x3e\x13\xdc\x49"
        "\x70\x7b\xb8\xb5\x94\xbd\x9c\xf3\x10\xb0\xc4\x46\x6c\x80\xc1\x07\xb1"
        "\x6f\xf9\x48\x3f\x66\x8b\x6c\xf9\xfe\xfb\x22\xf6\xf8\x49\xe0\xc7\x68"
        "\xf4\x6b\xd5\x76\x19\x05\x9d\xec\x5b\xdd\x5a\x6f\x7d\x28\x1f\x90\x02"
        "\x83\xbc\xe8\x22\x8a\xe6\x4e\x47\xe4\x9c\x83\x3f\xca\xb5\x86\xe6\xb3"
        "\x9a\xec\xdc\xf9\xfe\x0e\x23\x59\xbe\xd1\x87\x21\x1a\xa3\xef\xf0\xd9"
        "\x34\x26\xf1\x57\x8b\x2d\xc4\x01\x38\x01\xf1\x1e\x94\xe8\xf5\x14\x64"
        "\x00\x83\xdc\xae\x7d\xd1\xc7\x0d\x73\x91\xbb\xd4\x0c\xd2\x20\x9a\x63"
        "\x62\xad\x92\xd9\x59\x76\x29\xfe\x71\x0f\xb6\xbf\x75\x25\x44\x68\x5c"
        "\x93\xda\x71\xbd\xcf\xa9\x96\x32\xd7\xe0\xb9\xbe\x8b\xb3\x5d\x2a\xaa"
        "\xc2\x19\x1c\xc6\x6b\xc9\x06\x62\x9e\xeb\x49\xa9\xdc\xbb\x3d\x08\x69"
        "\xe7\x1c\xa7\xf8\x01\x99\xd2\x9b\x22\x2b\x9e\xfc\xe3\xdc\xb9\x68\x9f"
        "\xa7\x4d\xbb\xd8\xf8\xa9\x89\xcc\xba\xc3\x99\x5f\x67\xee\xe4\xf5\x63"
        "\xd6\x25\xa7\x15\x22\xb4\x0e\x1c\x44\xb9\x49\xa8\x89\xbd\x1e\xfa\x71"
        "\x4a\xb2\xd9\x2f\x61\x34\x0e\x5a\x2e\x34\x4b\xf3\xe8\x7c\x6e\x32\xcf"
        "\x51\x82\xac\xea\x2b\x40\xd8\x3e\x66\x02\x6d\xf3\x24\x21\xa7\x46\x2f"
        "\x33\xc3\xe1\xed\x10\xbf\x66\x62\xea\x68\xd0\xd9\x54\x9c\xba\xda\xe5"
        "\x9a\x1a\x73\xf3\xc1\x50\xa2\xfc\xb3\xd0\x71\xa2\xc9\x30\xa0\xa1\x68"
        "\xfb\xed\xbc\xbd\xcf\xa2\x65\x2b\xe9\x43\xb6\xd5\xb3\xa9\xd5\x95\x7b"
        "\x14\xe6\xe4\xb4\xb5\xd3\x85\x9e\x8c\x35\x40\x79\x84\x63\x73\x07\xcf"
        "\x1e\x7b\x91\x8f\x1e\xd8\xd9\xc7\x98\xcc\x07\x3e\xb2\x01\xf5\xbd\x88"
        "\x2e\x21\xc3\x06\x75\x0c\x2e\xe1\x5f\x47\x69\x5d\x22\x50\xcb\xc3\xd0"
        "\x34\x8e\xae\x7b\x6f\xe1\x35\x89\x88\x3d\x8a\xc9\xec\x70\x57\xfa\x56"
        "\x55\x52\x28\x13\x68\x7d\x60\x8e\x67\xb2\xfa\x23\x8c\xc0\xc0\x13\x7a"
        "\x1a\x4d\xf2\x05\x75\x2f\xfc\x25\xf7\xa8\x44\x3b\x36\xab\x13\xb3\xeb"
        "\x86\x1e\x42\x4d\xfb\xf7\x3c\x9e\x5b\xe0\x97\x9a\xef\xcc\x06\xdc\x3c"
        "\x5c\x56\x33\xfc\x14\x33\x15\x83\x67\x9e\x0c\x52\xe3\xaf\x4a\xd1\x74"
        "\xea\xa3\xec\xfb\x87\xc0\xfd\x1e\xa9\xc2\x04\x52\x8a\xa9\xbd\x8c\x66"
        "\x10\x1d\x41\xf5\x50\x9c\x19\x23\x3b\x66\xb8\x87\x39\x17\x77\x49\x1e"
        "\x12\xe7\x72\xa5\xcd\x27\xcd\xf0\xd2\xb7\x43\xf1\x7b\x95\x5a\xf5\x36"
        "\xd1\xba\x19\x48\x09\x53\x7d\x09\xff\x95\xe3\x76\xaa\xa9\x26\xe8\x4e"
        "\x31\x12\x88\x0a\x2e\x38\xa5\x81\x36\xd6\x7e\xac\x6a\x31\x13\x34\x67"
        "\x8d\x0c\x16\x08\x40\x95\xb0\x6f\x4c\x85\xe3\x52\x40\x6c\x89\x69\x03"
        "\xab\xb5\x67\xbe\xf6\x3f\x23\x65\xb0\x34\x03\x37\x68\xc1\xa6\x2e\xc9"
        "\xfa\x3b\x80\x0c\xf1\x22\x0c\x46\x8f\x58\xe4\x2a\x99\x27\x11\x07\x5b"
        "\x14\x34\x76\x86\x29\x98\x8d\x78\xdf\x95\x73\x4c\x99\x83\x9c\xf7\x2e"
        "\x7f\xc4\x0f\x41\x29\x18\xf6\x56\x06\xab\xa9\x51\xae\x2e\xb9\xaa\x52"
        "\x46\xcb\x15\xd4\xb6\x39\x53\x9a\x62\x21\x4f\x1b\xcd\x1b\x98\x0a\x2a"
        "\x5c\xa1\x87\xad\x76\x91\xd8\x2e\xd3\x69\x05\xf2\xbd\x57\x45\xce\x14"
        "\x5c\xf2\x3f\x84\xf0\xc2\xec\xde\xb7\x87\x43\xfd\xa6\x48\xa9\xe3\x9e"
        "\x61\x69\x95\xd7\xa1\xf9\x6f\xc7\xda\x7e\x8f\xf8\xd6\x22\x88\x0d\xb1"
        "\xfa\xa9\x78\x00\x1e\x82\x19\x57\x42\x4a\xd1\x70\xcf\x15\xbe\x5d\x67"
        "\x69\x21\x58\x6b\xfd\x06\x51\xa9\x6c\x5c\xb2\x70\x52\x67\x8c\xf8\x4f"
        "\x46\xb1\xb1\x5f\x8d\x42\x95\x0a\xf1\xca\x5d\x68\xb4\x37\x3c\x96\xe5"
        "\xdd\x3a\x1c\xb3\x04\x07\x5b\x8e\x48\x80\xcf\x15\x1b\x13\x89\x34\x19"
        "\xc7\xa8\x19\x4a\x86\x86\xe5\x58\xa4\x2f\xe2\xed\xb3\x95\xb2\x21\x60"
        "\xff\xd8\x1c\xb8\x33\x53\xfc\x5a\xc4\x3d\x9d\x4c\x5e\xc6\x50\x1e\xea"
        "\xe7\x03\xad\xaa\x35\xcd\x35\x88\x5e\xef\x3f\x1d\x53\xb7\xec\xec\x2c"
        "\x10\x17\xd9\xd0\xcc\xda\xf4\x17\x5e\x31\x7b\x46\x29\x65\x13\x9f\x8b"
        "\xb8\xb9\xd2\xac\x78\x40\xe8\xad\x22\xce\x2e\x74\x82\x1a\x9b\xd6\x90"
        "\xfe\x08\x96\xae\x40\x3d\x15\xf4\xc3\xfe\x8a\xb4\x7b\x1b\xd3\xfc\x32"
        "\x9c\xed\x72\xdc\x88\x96\x8c\xb2\x9a\x87\xdb\xa3\x80\x5c\x65\x89\x08"
        "\xed\xe5\x27\xf9\xaa\xf9\xf2\x4a\xf2\xc0\x86\x8e\xec\xc9\xa1\xad\x6b"
        "\xa3\xe8\xc7\xc8\xa4\x27\xdc\x1c\xcb\x03\xc2\xb7\x16\xba\xd7\x56\xda"
        "\xcc\xc2\xcc\x70\xf1\x2d\x67\x8b\xd7\xa8\xff\x81\x07\xa3\x3b\xfa\x83"
        "\xe7\xe1\x91\xcc\xba\x31\x3c\x71\x41\x2a\x8e\x12\x1b\x22\xda\x38\x02"
        "\x76\x3a\x31\x2d\xa3\xa9\x37\x22\xc8\xd0\x3c\x17\x26\xf8\xe6\x8e\x82"
        "\xbe\x28\x8b\xd7\x47\x88\xe0\x3b\xa7\x0e\x0d\xa2\xa5\x5d\xc4\x39\xcd"
        "\x49\x9e\xaa\xe0\xa9\x88\xcf\x3d\x19\xc3\x57\x09\xc5\xa5\x90\x9f\x61"
        "\xcc\xa7\x40\x19\x12\x88\x65\x21\xcb\xb1\xdd\xd8\x83\x02\x2a\x41\x0c"
        "\x15\xda\x5f\x14\x5c\x48\x42\x91\x3a\x5b\x33\xbb\x9b\x39\x56\xd7\x30"
        "\x10\x03\x47\x74\x2a\x1d\x21\xd4\x25\xaa\x0b\x1e\x49\x09\xc8\xae\x35"
        "\x93\x14\x5b\x83\x56\x3f\xa5\xe0\x09\x0f\x0e\x12\x37\x01\xb2\x4b\xa6"
        "\xab\xe5\x22\x57\x6d\x3a\x1f\xbf\x31\x1b\x7c\xa5\x2e\x71\xf9\xe1\x3c"
        "\xc8\x29\x3a\x15\x37\x84\x62\x2e\x2f\xd5\x7a\x99\x58\x11\xd8\xb9\x6c"
        "\xb2\x85\xaa\xa4\x63\xbb\x31\x64\x42\x7d\xc3\x64\x46\x3c\x34\xe3\xe0"
        "\xe3\x7b\x12\x95\x43\x24\xb3\xc0\x9e\xea\xe6\xd9\xe5\x8e\xa4\xdd\x2b"
        "\x6a\x41\x6f\xa8\xb3\x07\x43\xf7\xe3\xad\xbc\x43\x30\x8d\x73\x6d\xc9"
        "\x9d\x9e\x55\x74\x7f\x8d\x4c\x32\xb6\x7c\x29\x89\x3a\xa2\x30\x5f\xa3"
        "\xab\xc6\x4e\x77\xfc\xa7\x5f\x44\xde\x72\x32\x8c\xb2\x52\x3a\xe4\x48"
        "\xfc\xd8\x09\x5c\xc8\xd6\x58\x00\xb2\xe9\xaf\x5b\x95\x3b\x19\xc1\x23"
        "\x1c\x75\x5a\x71\x61\x2e\x7d\xd5\xf5\xde\x21\xbc\x91\xe0\x31\x1b\x62"
        "\x1a\x6c\x91\x37\xd9\x4d\xfb\xe6\x50\x82\x7b\x8e\x5d\xf1\x0d\xba\x45"
        "\xbc\x11\xc3\xed\xf9\x96\xa3\xad\x56\x40\x19\x37\xfe\x46\xe4\x71\xaf"
        "\x5f\x21\xcc\x7d\x4a\xae\x7b\x8c\x95\x5f\x92\x6b\x65\xb8\xe4\x14\x90"
        "\x23\xb9\x85\xf7\xa0\x55\x85\x0c\x6a\x74\x95\x7b\x39\xec\x97\x01\xe3"
        "\x05\x85\xa2\x3a\x92\xec\x40\x19\xb4\xc2\x68\xe5\xb5\x44\xb1\x56\xf5"
        "\xb2\x29\x5b\x8a\xbf\xfb\x8e\xf0\xea\xe3\x07\x73\x88\x6a\x61\x34\xac"
        "\x3b\xe5\xbe\xc8\xe0\x09\xaf\xf7\x47\x96\x07\x5e\x58\xe8\xb3\x11\xd9"
        "\xe8\x40\xf0\x13\x21\xca\xa3\xd4\xf7\x6d\xb2\x62\x83\x68\x8d\xad\xe5"
        "\x43\x24\xb8\x82\x95\x06\x99\x7d\x42\xb9\x0a\x93\x60\x01\x2a\x22\x3f"
        "\xf3\x98\xde\x4e\xd4\x45\xa8\xe4\xf9\xf5\x9e\x24\x64\x1e\x59\xec\x16"
        "\x33\xdf\xd5\xd6\xd2\xe1\x71\x12\x86\xee\x08\xd0\xc0\xe9\x3c\x4f\x13"
        "\xf8\x9f\xc9\xce\x98\xf2\x25\x97\xaf\xcf\x99\xe8\x53\x47\x66\x43\x3a"
        "\xa3\x92\xb5\xb4\xa5\xfb\xd4\x75\x98\xca\x1b\xb5\x41\xf3\x74\xdc\xd8"
        "\xe3\x94\x73\x70\x46\x2a\x1c\xe2\x5f\x79\x49\xc2\x8a\xba\xe8\xe9\x24"
        "\x85\x12\xcd\xcd\x5a\x53\x8a\xd3\x1c\x86\xe6\xe2\xf7\x83\xad\xf5\x4a"
        "\xba\xa8\x27\xf4\xf9\x3d\xd1\xfe\x32\x5a\x67\x2a\xaa\x77\x08\x2b\xc6"
        "\x5b\x0d\xb7\x84\xf8\x5f\xdc\xe7\xaf\xf2\x2f\xe6\x32\x46\xb9\xd5\x5e"
        "\x6d\x98\x2e\x8f\xf1\xbc\x4e\xb9\x68\x2e\x96\xf3\x03\xc1\x13\x54\x62"
        "\xdd\xc6\xad\xa4\x26\x49\x2f\x82\x30\xd0\x5a\x15\x53\x47\x49\xb1\xcf"
        "\xc1\x5f\x2a\xc7\x21\x2f\x67\xa0\x2f\x45\xad\x97\xf2\x74\x1d\xc4\xa5"
        "\x8d\x3d\xa7\x6b\x0a\xce\x04\x67\x11\x9a\x51\xeb\xa3\xde\xcf\x89\x9e"
        "\x7e\x93\x64\x02\x98\xcc\x9d\x33\x4d\xae\x1d\xd5\xbc\x27\x15\x42\xde"
        "\x34\x0a\x23\xd8\x8b\x38\x12\x75\x9c\xd8\x36\x68\x2a\x00\x29\xcc\x23"
        "\x61\x4e\x62\xbb\xc5\xff\xa3\x26\xd6\x21\xaf\xbf\x78\x5e\xc8\xa1\x0a"
        "\x2e\x86\xb5\xf3\xdd\xc9\xc1\x34\xb6\x98\x90\x3a\xa3\x64\x49\x9f\x4c"
        "\x5c\x14\x6c\x03\xf8\xdf\x64\xf2\xed\xc2\xa4\xd3\xb8\x79\x7a\xdd\x43"
        "\x56\xd9\xc0\xdf\xe6\xe1\xf3\xa8\x13\x39\x3a\xaf\x7c\xa6\x0c\x93\xbc"
        "\x4d\x18\x5f\xfb\xea\x14\x98\x53\x08\xa8\xb1\xd6\xb1\x7d\x81\x7b\x7b"
        "\xbe\x05\xc0\xe5\x8a\x1f\x95\x2d\x87\x70\x84\x87\x67\xc7\x9e\x19\x40"
        "\x93\x14\xf9\xb6\xee\x0a\x8f\x63\x1f\x93\x5d\x2a\xa6\x06\xcd\x7e\x2d"
        "\x49\x39\xd2\x6b\xb7\x40\x2c\x70\x61\xc1\x63\x11\x4c\x38\xf3\x56\xa9"
        "\x52\xfe\xa0\x0b\xa2\xb5\x80\x01\x8b\xa5\xc8\x30\xc7\x48\xcd\x7c\xab"
        "\x54\xa8\x40\x6e\x00\x21\xe9\x16\x89\xdf\x52\xd3\x92\xf8\x94\x30\xd2"
        "\x06\xcc\xdd\x0c\x01\x23\x49\x00\x0b\xa3\x12\xde\xf0\xdc\xcb\x6f\x1d"
        "\x38\x35\xc7\x60\x8e\xd6\xa4\xc5\xbd\x4a\x92\x7e\x32\xc8\xa2\xba\x12"
        "\xfd\x3f\x35\x1f\xa5\x43\xec\xf8\x81\x60\x60\x0f\xb2\x5e\x05\x55\x9e"
        "\xf2\x88\x23\xf7\xee\x85\x5d\x61\x59\x1e\x54\x96\xa7\xb5\xa1\xbd\x83"
        "\x35\x21\x41\xbb\x42\xb1\x04\x9c\x7a\x32\x20\xcd\x34\xde\xf4\x93\x8c"
        "\x8d\xb0\x97\xb8\x37\x1d\xa3\x78\x2d\x81\xed\xc6\x8c\xe3\x85\x20\x6c"
        "\x79\xe6\x5b\xcc\x30\x5b\x7a\xdc\x12\x6e\x22\x92\xc5\xfd\x00\x02\x33"
        "\xf6\x6e\xa0\x6a\xb6\x46\xaf\x76\x79\x68\xee\x86\xed\xcd\xbf\xd3\x5f"
        "\x47\xeb\x04\x56\xe7\x00\x52\xed\x5d\x4f\xf7\x50\x0f\x9d\x37\x42\xbe"
        "\x4c\x06\xd0\x07\x76\xed\x3f\x4b\x91\xc7\x4a\x13\x98\xbc\x96\x20\xb4"
        "\x87\xf0\xec\x56\x68\x9c\x76\x1b\xbc\x95\x56\x97\x1a\xd5\x36\x04\x11"
        "\x81\x58\x82\x02\x9e\x94\xb2\xf6\x2f\xb2\x92\xc3\x7a\xff\xa5\xec\xed"
        "\x85\x3b\xf8\xf3\xab\x8d\x2e\xf3\x82\x78\x80\x74\x5d\x86\xdb\xa3\x51"
        "\x0e\xba\x4b\x59\x5a\xc0\x11\xed\x5a\x9e\x10\x76\x09\xec\x02\xc1\xef"
        "\x9b\x77\x95\x4f\xdb\x3b\x9d\xd3\x49\xf2\xe9\x02\xd4\x5a\xfe\x81\x21"
        "\xa6\x28\x1e\xd8\x39\x1b\xd6\x2b\x0a\xfe\xbb\x2a\xb6\x27\x6c\x05\x76"
        "\xfc\x22\xae\x3c\x86\x4b\xe6\xd3\xbb\xf4\x8d\x37\x63\x03\xaa\x98\xca"
        "\x70\xc3\x08\xe4\xe6\x74\xb8\x9c\x49\x6b\x40\xdd\x39\xdb\xf0\x97\xb3"
        "\x4f\xce\x3d\x67\x7a\x0c\x6d\x96\x70\x89\x8c\x27\x6b\xbf\x15\x89\x4d"
        "\xfd\xcf\x70\xd2\xea\x1d\x6c\x8f\xa8\x12\xf4\xb3\x03\x40\xe3\x30\xaf"
        "\x3f\x83\xda\xaa\xea\xd9\xa5\x08\x5e\x8e\x87\x83\xaa\xfb\x8c\x99\xba"
        "\xd6\xbd\x32\xc7\x89\x92\x33\xf7\xc0\x77\x32\xbc\x87\xec\x0e\x4d\x42"
        "\x9b\xe0\x87\x8a\x12\xdd\xf2\x6c\x51\x30\x32\xc7\x20\x02\xa4\x6b\x0d"
        "\x01\xfa\xd6\xb1\x04\x07\x32\x52\x54\x49\xf2\x8d\x04\x81\x32\xc2\x6c"
        "\x2b\xe5\x1f\x52\x05\x04\xd5\x0f\x15\x73\x92\xd5\x85\x19\xc1\x0f\xce"
        "\xf6\x5f\x7b\x6d\xe0\xac\x56\x6a\x4c\xba\x93\x6e\x74\xe7\x1e\x51\xe6"
        "\xb3\x2a\x17\xc3\x78\x17\x5b\xee\x79\x84\x37\x60\xc5\xa0\x8b\x29\xe2"
        "\xda\x42\x8c\x39\x9a\x2e\xcf\x56\x5a\x78\x52\xdf\x20\x8f\x6c\xa8\xe5"
        "\xcd\xea\x2e\xe6\xb5\x50\x61\xe6\x6c\xfd\x55\xc3\xca\x37\x46\xbb\x8a"
        "\x33\x01\x63\x5e\x92\x94\x6f\x8d\x93\x67\x31\xcd\xc4\x22\x4b\xfd\xab"
        "\x03\x33\xcb\x9d\xf8\x8c\x12\x4e\x51\xcb\x6d\x64\xc1\xda\x1b\xe3\x0b"
        "\x40\x3c\x55\xa5\x49\xbd\xa2\x3e\xf2\xa8\x17\xfb\xbd\xcb\x20\x23\xf3"
        "\x80\x8c\x86\xce\xd0\xe4\x75\x8c\xda\x88\x73\xbb\x81\x9c\xd6\x16\x50"
        "\x0a\x9d\x34\x6a\xa5\x4a\x85\x05\xd4\x3c\xc2\xe9\x2f\x37\x7b\xfc\x39"
        "\x69\xcf\xd0\xc8\x0c\x42\x3d\x35\xdf\x3d\x05\x37\x7b\x13\x00\x84\x8a"
        "\x6f\xe7\xe5\xfa\xb1\x3c\xf1\xff\x88\x3c\x42\xc6\xba\xd0\x1d\xef\x32"
        "\xd2\x88\x84\xe6\x4d\xfd\xb7\x96\xe4\x29\xfd\xa4\xbb\xdf\xc3\xed\x28"
        "\x90\x7a\x83\xf0\x11\x1c\x10\x66\xc0\x62\x32\x45\xb9\xc7\x21\x2e\xf2"
        "\x85\x87\xd9\x08\xeb\x72\xed\xa4\xcb\x56\x85\xd1\xba\xa8\x25\x9c\x5a"
        "\x92\x5f\x5c\x2f\xd0\x59\x9e\xd9\x07\xf6\x06\x75\xc2\x25\xc2\xee\x05"
        "\x1d\x2f\x82\x9a\x85\x25\xd2\x0a\xee\x09\x07\x1e\x62\x35\xb1\x7a\x47"
        "\xec\x9a\xd7\xa9\xef\xcd\x73\xe3\x4e\xd1\xdb\x00\xe7\x5a\x42\xeb\x81"
        "\x41\x2e\x07\x29\x31\x9a\xaa\x20\xeb\x7a\x87\x6a\x57\x34\x40\xf5\xdf"
        "\x28\x8a\xb9\x06\xa1\x89\xb4\xbd\x24\x1a\x4c\xb1\x27\x0c\x93\xc3\x90"
        "\xe5\x20\xd7\x8b\x36\xac\xa0\x70\x84\xa3\x3f\x14\x10\xd1\x07\x4d\x31"
        "\x78\x72\x4d\xf5\x26\xdd\xa7\x07\x4a\x2a\x87\xe6\x55\xb4\x0f\xa2\x66"
        "\x47\x7a\x4f\x87\x33\x4e\x23\x2c\x23\x87\xcf\x7f\xe5\x19\x5c\x1d\x81"
        "\xa0\xf3\x32\x84\x57\xdb\x81\x1d\x3e\x98\x95\x05\x81\xf9\xc4\x13\xcf"
        "\x80\xaf\x80\x08\x46\x50\x58\xd3\x12\xb5\x2c\xc4\xc9\x3c\xe7\x2f\x70"
        "\x10\x1c\x8b\x8f\x08\xb6\xc0\x8f\xf1\xd7\xfd\xb2\x84\xa7\xcc\xca\xd7"
        "\x75\x06\xa3\x19\xba\xf5\x45\x12\x90\xdd\xbe\x26\xde\xa3\x31\xd8\xbd"
        "\xa5\x46\x12\xef\xf8\x6d\x66\xa8\x26\xf4\x42\xb9\xc3\xdd\x7f\x59\x75"
        "\x7d\xb9\x5c\x40\xdb\xda\x34\x1a\x99\x8f\xc2\xc7\x15\x7f\xe8\xa7\xd3"
        "\x9c\x49\x17\xcc\x5c\x52\xf9\x49\x41\xb0\xf9\xe5\x94\x88\x04\x89\xa8"
        "\xff\xf3\x1e\x49\x92\x77\x9a\x58\x64\xe1\xe0\xd2\xce\x89\x19\xf7\x86"
        "\x78\xff\xee\x04\x41\xc4\x0c\xa2\x19\xea\x27\xb5\xb5\x46\x00\x6c\xd8"
        "\xde\xc3\x37\xe0\x28\x0c\xa8\x7c\x05\x7a\xa3\xc1\xf5\x1f\x68\x78\x03"
        "\xd9\x20\x91\x97\x20\x22\x89\xfb\xd0\x5c\x1f\x1d\x9c\xc8\xe2\xcd\xfd"
        "\x5f\x33\x9b\x58\x5a\x64\x62\xcb\x23\x90\xe6\x95\x6c\x51\x0a\xf2\xf9"
        "\xe7\x5a\xdc\x0e\x4f\x94\x16\xb8\x3e\x56\xdc\xb8\xdc\x0c\x2b\xe6\xc9"
        "\x94\xbb\x2f\xed\xff\xc9\x81\x26\x89\x46\xb3\x0e\x0a\x6f\x4c\x75\x2e"
        "\xde\xcf\xdd\x99\xaf\xb9\x4b\x1c\xee\x68\x7b\x6d\x9a\x80\xcb\xd2\x1a"
        "\x7d\xa3\x69\xc9\x0c\x6a\xaf\xe9\xcc\xaf\xb0\xb2\x5a\x28\xa6\x96\xb8"
        "\xb0\x6f\x4a\x8c\xfd\xa9\xba\xa2\xac\xaa\x40\x7a\xd2\x6c\x27\xab\xc8"
        "\x1f\xe2\x95\xec\x05\x9c\x14\x23\x0a\x58\x71\xb7\xf7\xcb\x9f\x46\xc1"
        "\x04\x80\xaa\x1f\xf6\x3a\x83\x84\xb2\x3d\xd4\xa8\xb6\xb8\x72\x6a\xc2"
        "\x64\x87\x55\xf4\xe5\x28\x5a\x06\xec\xab\xc1\xc9\x67\x1a\xf9\xd6\x22"
        "\x7a\x48\x84\x05\x98\x10\x69\x24\x73\x46\x17\x35\x3a\x4f\x63\x4d\x2a"
        "\x5a\xf3\x45\x36\xc9\x4e\x95\xb6\xb7\x6f\xa5\x13\xd2\xb3\xb4\x53\x4d"
        "\x1e\x22\x4e\xec\x08\x1e\x3b\x29\x81\xbc\xad\x33\x4f\x64\x58\xcd\x96"
        "\xeb\x3d\x29\xfd\x86\x97\xae\x15\x6c\x64\x65\x6a\x41\xb6\x6e\x13\xa9"
        "\xc2\x69\xfe\x76\x41\x84\x8b\xc7\x72\x37\xda\x59\x88\x3e\xcb\xe7\xba"
        "\xd5\x95\x59\x1c\x0a\x26\xb1\x64\x5c\xc8\x67\xcb\x52\x70\xa2\x59\x8a"
        "\x20\xea\x86\x51\xfa\x52\x67\x43\xc2\xf2\x8a\x11\xa3\x23\xa1\xeb\xb8"
        "\x70\x4d\xd8\x66\xaf\xdf\x35\x1c\x73\x48\x2c\x40\x28\xcc\xae\x39\xc2"
        "\x52\x85\x34\xe4\x05\x55\x09\xd9\xde\x00\x45\xe2\xd6\x0c\x8e\xc5\x6b"
        "\xee\x66\xc5\x1d\xf6",
        4085);
    syscall(__NR_write, -1, 0x20000b80ul, 0xff5ul);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  for (procid = 0; procid < 6; procid++) {
    if (fork() == 0) {
      loop();
    }
  }
  sleep(1000000);
  return 0;
}
