// https://syzkaller.appspot.com/bug?id=8bb5b7e42e49c84d1a7218775fe92853d610bad5
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#define BITMASK(bf_off, bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type, htobe, addr, val, bf_off, bf_len)               \
  *(type*)(addr) =                                                             \
      htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) |           \
            (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

const int kInitNetNsFd = 201;

static long syz_init_net_socket(volatile long domain, volatile long type,
                                volatile long proto)
{
  return syscall(__NR_socket, domain, type, proto);
}

uint64_t r[1] = {0xffffffffffffffff};

int main(void)
{
  syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
  syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
  intptr_t res = 0;
  res = -1;
  res = syz_init_net_socket(0x10, 3, 0x10);
  if (res != -1)
    r[0] = res;
  *(uint64_t*)0x20001ac0 = 0;
  *(uint32_t*)0x20001ac8 = 0;
  *(uint64_t*)0x20001ad0 = 0x20000640;
  *(uint64_t*)0x20000640 = 0x20000240;
  *(uint32_t*)0x20000240 = 0x11c;
  *(uint16_t*)0x20000244 = 0x29;
  *(uint16_t*)0x20000246 = 1;
  *(uint32_t*)0x20000248 = 0;
  *(uint32_t*)0x2000024c = 0;
  *(uint16_t*)0x20000250 = 0x10b;
  STORE_BY_BITMASK(uint16_t, , 0x20000252, 0, 0, 14);
  STORE_BY_BITMASK(uint16_t, , 0x20000253, 0, 6, 1);
  STORE_BY_BITMASK(uint16_t, , 0x20000253, 1, 7, 1);
  *(uint16_t*)0x20000254 = 0xc;
  STORE_BY_BITMASK(uint16_t, , 0x20000256, 0, 0, 14);
  STORE_BY_BITMASK(uint16_t, , 0x20000257, 0, 6, 1);
  STORE_BY_BITMASK(uint16_t, , 0x20000257, 0, 7, 1);
  *(uint64_t*)0x20000258 = 0;
  *(uint16_t*)0x20000260 = 0xc;
  STORE_BY_BITMASK(uint16_t, , 0x20000262, 0, 0, 14);
  STORE_BY_BITMASK(uint16_t, , 0x20000263, 0, 6, 1);
  STORE_BY_BITMASK(uint16_t, , 0x20000263, 0, 7, 1);
  memcpy((void*)0x20000264, "!\\$].\024^\000", 8);
  memcpy(
      (void*)0x2000026c,
      "\x50\xbb\x2d\x6f\x67\xcf\x9d\x6f\xab\xad\xb1\x07\xd0\xde\xf4\x9c\x88\xea"
      "\x04\xab\xde\x1d\x5e\x8d\x3f\xb2\x2a\x1b\x50\x46\x77\x8b\xda\xfe\xfc\x46"
      "\xb0\x44\x9a\x23\x48\xc2\x6c\x21\x26\x23\x7d\xd5\xb3\x7f\x5a\xe6\x55\xb1"
      "\x08\x6c\xda\x40\xe0\x0a\xec\x58\x75\x47\x34\xbe\x31\xd7\x50\x35\x1d\xc0"
      "\x76\xeb\x47\xd9\x62\x19\xc0\x8c\x02\x9d\x16\x08\xa4\x87\xf2\x6f\xbe\x81"
      "\x6b\x89\xf7\xcb\x81\xbf\xf8\x1a\x8b\x7a\x82\x56\x58\x56\x55\x5e\xe9\x23"
      "\xc6\x59\x73\xde\xb0\xa9\x9b\x96\x2b\xc0\xfe\x94\xa3\xec\xfc\xae\x36\x97"
      "\xbd\x7b\x85\xb3\xa2\x82\x16\x7c\x43\xdb\xf1\x37\x11\x5a\x40\xeb\xdd\xca"
      "\xd7\x48\x75\xcf\x0d\x97\x2d\xf9\xe9\x9f\x07\x97\x67\x73\xf4\xd9\x8f\xe3"
      "\xfa\x37\x0d\x47\xeb\x64\x0d\xc5\x06\x1d\xc3\x58\x17\xc8\xa6\x6c\x29\xbe"
      "\x82\xfd\xc3\xf4\x39\x3c\x05\xa0\x07\xd1\x2b\x50\x5a\x84\xdf\xdb\x98\xd5"
      "\x68\x17\x5b\x62\xc6\x3d\xff\xc4\x7e\xfb\x84\x74\x42\x1d\x72\x6d\x1e\x53"
      "\x31\xe1\xdd\xfd\x4d\xf7\x0b\x57\xe0\x00\x00\x00\x00\x00\x00\x00\x00\x00"
      "\x00\x00\x00\x00\x00",
      239);
  *(uint64_t*)0x20000648 = 0x11c;
  *(uint64_t*)0x20001ad8 = 1;
  *(uint64_t*)0x20001ae0 = 0;
  *(uint64_t*)0x20001ae8 = 0;
  *(uint32_t*)0x20001af0 = 0;
  syscall(__NR_sendmsg, r[0], 0x20001ac0ul, 0ul);
  return 0;
}
